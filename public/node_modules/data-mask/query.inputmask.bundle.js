/ *!
* jquery.inputmask.bundle.js
* https://github.com/RobinHerbots/jquery.inputmask
* Copyright (c) 2010 - 2016 Robin Herbots
* Sous licence MIT (http://www.opensource.org/licenses/mit-license.php)
* Version: 3.3.4-108
* /
! function ($) {
    function Inputmask (alias, options) {
        renvoyer cette instance de masque de saisie? ($ .isPlainObject (alias)? options = alias: (options = options || {},
        options.alias = alias), this.el = vide 0, this.opts = $ .extend (! 0, {}, this.defaults, options), 
        this.noMasksCache = options && void 0! == options.definitions, this.userOptions = options || {},
        this.events = {}, this.dataAttribute = "data-inputmask", annule this.resolveAlias ​​(this.opts.alias, options, this.opts)): new Inputmask (alias, options);
    }
    function generateMaskSet (opts, nocache) {
        function generateMask (masque, métadonnées, opts) {
            if (null! == mask && ""! == mask) {
                if (1 === mask.length && opts.greedy ===! 1 && 0! == opts.repeat && (opts.placeholder = ""), 
                opts.repeat> 0 || "*" === opts.repeat || "+" === opts.repeat) {
                    var repeatStart = "*" === opts.repeat? 0: "+" === opts.repeat? 1: opts.repeat;
                    mask = opts.groupmarker.start + mask + opts.groupmarker.end + opts.quantifiermarker.start + repeatStart + "," + opts.repeat + opts.quantifiermarker.end;
                }
                var masksetDefinition;
                return void 0 === Inputmask.prototype.masksCache [masque] || nocache ===! 0? (masksetDefinition = {
                    masque: masque,
                    maskToken: Inputmask.prototype.analyseMask (masque, opte),
                    validPositions: {},
                    _buffer: vide 0,
                    tampon: vide 0,
                    tests: {},
                    métadonnées: métadonnées,
                    maskLength: vide 0
                }, nocache! ==! 0 && (Inputmask.prototype.masksCache [opts.numericInput? mask.split (""). reverse (). join (""): mask] = masksetDefinition, 
                masksetDefinition = $ .extend (! 0, {}, Inputmask.prototype.masksCache [opts.numericInput? mask.split (""). reverse (). join ("":: masque]))): masksetDefinition = $. extend (! 0, {}, Inputmask.prototype.masksCache [opts.numericInput? mask.split (""). reverse (). join ("": masque:]]), 
                masksetDefinition;
            }
        }
        var ms;
        if ($ .isFunction (opts.mask) && (opts.mask = opts.mask (opts)), $ .isArray (opts.mask)) {
            if (opts.mask.length> 1) {
                opts.keepStatic = null === opts.keepStatic || opts.keepStatic;
                var altMask = opts.groupmarker.start;
                return $ .each (opts.numericInput? opts.mask.reverse (): opts.mask, function (ndx, msk) {
                    altMask.length> 1 && (altMask + = opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start), 
                    altMask + = void 0 === msk.mask || $ .isFunction (msk.mask)? msk: msk.mask;
                }), altMask + = opts.groupmarker.end, generateMask (altMask, opts.mask, opts);
            }
            opts.mask = opts.mask.pop ();
        }
        return opts.mask && (ms = void 0 === opts.mask.mask || $ .isFunction (opts.mask.mask)? generateMask (opts.mask, opts.mask, opts): generateMask (opts.mask. masque, opts.mask, opts)), 
        Mme;
    }
    function maskScope (actionObj, maskset, opts) {
        fonction getMaskTemplate (baseOnInput, minimalPos, includeMode) {
            minimalPos = minimalPos || 0;
            var ndxIntlzr, test, testPos, maskTemplate = [], pos = 0, lvp = getLastValidPosition ();
            maxLength = void 0! == el? el.maxLength: vide 0, maxLength === -1 && (maxLength = vide 0);
            do baseOnInput ===! 0 && getMaskSet (). validPositions [pos]? (testPos = getMaskSet (). validPositions [pos],
            test = testPos.match, ndxIntlzr = testPos.locator.slice (), maskTemplate.push (includeMode ===! 0? testPos.input: includeMode ===! 1? test.nativeDef: getPlaceholder (pos, test)) : (testPos = getTestTemplate (pos, ndxIntlzr, pos - 1), 
            test = testPos.match, ndxIntlzr = testPos.locator.slice (), (opts.jitMasking ===! 1 || pos <lvp || Number.isFinite (opts.jitMasking) && opts.jitMasking> pos) && maskTemplate. push (includeMode ===! 1? test.nativeDef: getPlaceholder (pos, test))), 
            pos ++; while ((void 0 === maxLength || pos <maxLength) && (null! == test.fn || ""! == test.def) || minimalPos> pos);
            return "" === maskTemplate [maskTemplate.length - 1] && maskTemplate.pop (), getMaskSet (). maskLength = pos + 1, 
            maskTemplate;
        }
        fonction getMaskSet () {
            retour masqueset;
        }
        function resetMaskSet (soft) {
            var maskset = getMaskSet ();
            maskset.buffer = vide 0, souple! ==! 0 && (maskset._buffer = vide 0, maskset.validPositions = {}, 
            maskset.p = 0);
        }
        fonction getLastValidPosition (la plus proche, To, strict, validPositions) {
            var before = -1, after = -1, valids = validPositions || getMaskSet (). validPositions;
            void 0 === le plus proche && (le plus proche = -1);
            pour (var posNdx dans les valids) {
                var psNdx = parseInt (posNdx);
                valids [psNdx] && (strict || null! == valids [psNdx] .match.fn) && (psNdx <= plus procheTo && (avant = psNdx), 
                psNdx> = le plus procheTo && (after = psNdx));
            }
            retour avant! == -1 && le plus procheTo - avant> 1 || après <le plus proche? avant après;
        }
        fonction stripValidPositions (début, fin, nocheck, strict) {
            fonction IsEnclosedStatic (pos) {
                var posMatch = getMaskSet (). validPositions [pos];
                if (void 0! == posMatch && null === posMatch.match.fn) {
                    var prevMatch = getMaskSet (). validPositions [pos - 1], nextMatch = getMaskSet (). validPositions [pos + 1];
                    return void 0! == prevMatch && void 0! == nextMatch;
                }
                retourner! 1;
            }
            var i, startPos = début, positionsClone = $ .extend (! 0, {}, getMaskSet (). validPositions), needsValidation =! 1;
            for (getMaskSet (). p = début, i = fin - 1; i> = startPos; i--) void 0! == getMaskSet (). validPositions [i] && (nocheck! ==! 0 && (! getMaskSet () .validPositions [i] .match.optionality && IsEnclosedStatic (i) || opts.canClearPosition (getMaskSet (), i, getLastValidPosition (), strict, opts) ===! 1) || supprimer getMaskSet (). validPositions [je]);
            pour (resetMaskSet (! 0), i = startPos + 1; i <= getLastValidPosition ();) {
                for (; void 0! == getMaskSet (). validPositions [startPos];) startPos ++;
                var s = getMaskSet (). validPositions [startPos];
                if (i <startPos && (i = startPos + 1), void 0 === getMaskSet (). validPositions [i] && isMask (i) || void 0! == s i ++; autre {
                    var t = getTestTemplate (i);
                    needsValidation ===! 1 && positionsClone [startPos] && positionsClone [startPos] .match.def === t.match.def? (getMaskSet (). validPositions [startPos] = $ .extend (! 0, {}, positionsClone [startPos]),
                    getMaskSet (). validPositions [startPos] .input = t.input, supprimez getMaskSet (). validPositions [i], 
                    i ++): positionCanMatchDefinition (startPos, t.match.def)? isValid (startPos, t.input || getPlaceholder (i),! 0)! ==! 1 && (supprimer getMaskSet (). validPositions [i],
                    i ++, needsValidation =! 0): isMask (i) || (i ++, startPos--), startPos ++;
                }
            }
            resetMaskSet (! 0);
        }
        function DetermineTestTemplate (tests, guessNextBest) {
            for (var testPos, testPositions = tests, lvp = getLastValidPosition (), lvTest = getMaskSet (). validPositions [lvp] || getTests (0) [0], lvTestAltArr = void 0! == lvTest.alternation? lvTest.alternation lvTest.alternation] .toString (). split (","): [], ndx = 0; ndx <testPositions.length && (testPos = testPositions [ndx],
            ! (testPos.match && (opts.greedy && testPos.match.optionalQuantifier! ==! 0 || (testPos.match.optionality ===! 1 || testPos.match.newBlockMarker ===! 1) && testPos. match.optionalQuantifier! ==! 0) && (void 0 === lvTest.alternation || lvTest.alternation! == testPos.alternation || void 0! == testPos.locator [lvTest.alternation] && checkAlternationMatch (testPos. locator [lvTest.alternation] .toString (). split (","), lvTestAltArr))) || guessNextBest ===! 0 && (null! == testPos.match.fn || /[0-9a-bA-ZHER//testPos.match.def))); ndx ++);
            renvoyer testPos;
        }
        fonction getTestTemplate (pos, ndxIntlzr, tstPs) {
            retourne getMaskSet (). validPositions [pos] || DetermineTestTemplate (getTests (pos, ndxIntlzr? ndxIntlzr.slice (): ndxIntlzr, tstPs));
        }
        fonction getTest (pos) {
            renvoyer getMaskSet (). validPositions [pos]? getMaskSet (). validPositions [pos]: getTests (pos) [0];
        }
        fonction positionCanMatchDefinition (pos, def) {
            pour (var valid =! 1, tests = getTests (pos), tndx = 0; tndx <tests.length; tndx ++) if (tests [tndx] .match && tests [tndx] .match.def === def) {
                valide =! 0;
                Pause;
            }
            retour valide;
        }
        fonction getTests (pos, ndxIntlzr, tstPs) {
            fonction resolTestFromToken (maskToken, ndxInitializer, loopNdx, quantifierRecurse) {
                function handleMatch (match, loopNdx, quantifierRecurse) {
                    fonction isFirstMatch (latestMatch, tokenGroup) {
                        var firstMatch = 0 === $ .inArray (latestMatch, tokenGroup.matches);
                        return firstMatch || $ .each (tokenGroup.matches, function (ndx, match) {
                            if (match.isQuantifier ===! 0 && (firstMatch = isFirstMatch (latestMatch, tokenGroup.matches [ndx - 1]))) return! 1;
                        }), firstMatch;
                    }
                    function resolNdxInitializer (pos, alternateNdx, targetAlternation) {
                        var bestMatch, indexPos;
                        return (getMaskSet (). tests [pos] || getMaskSet (). validPositions [pos]) &&. .each (getMaskSet (). tests [pos] || [getMaskSet (). validPositions [pos]], fonction (ndx , lmnt) {
                            var alternation = void 0! == targetAlternation? targetAlternation: lmnt.alternation, ndxPos = lmnt.locator [alternance]? lmnt.locator [alternance] .toString (). indexOf (substitNNdx): -1;
                            (void 0 === indexPos || ndxPos <indexPos) && ndxPos! == -1 && (bestMatch = lmnt, 
                            indexPos = ndxPos);
                        }), meilleure correspondance ? bestMatch.locator.slice (bestMatch.alternation + 1): vide 0! == targetAlternation? resolutNdxInitializer (pos, alternateNdx): void 0;
                    }
                    fonction staticCanMatchDefinition (source, cible) {
                        return null === source.match.fn && null! == target.match.fn && target.match.fn.test (source.match.def, getMaskSet (), pos,! 1, opts,! 1);
                    }
                    if (testPos> 1e4) throw "Inputmask: Il y a probablement une erreur dans la définition de votre masque ou dans le code. Créez un problème sur github avec un exemple du masque que vous utilisez." + getMaskSet (). mask;
                    if (testPos === pos && void 0 === match.matches) renvoie match.push ({
                        match: match,
                        locator: loopNdx.reverse (),
                        cd: cacheDependency
                    }),! 0;
                    if (void 0! == match.matches) {
                        if (match.isGroup && quantifierRecurse! == match) {
                            if (match = handleMatch (maskToken.matches [$. inArray (match, maskToken.matches) + 1], loopNdx)) return! 0;
                        } else if (match.isOptional) {
                            var optionalToken = match;
                            if (match = resolTestFromToken (match, ndxInitializer, loopNdx, quantifierRecurse)) {
                                if (latestMatch = correspond à [matches.length - 1] .match,! isFirstMatch (latestMatch, optionalToken)) return! 0;
                                insertStop =! 0, testPos = pos;
                            }
                        } sinon si (match.isAlternator) {
                            var maltMatches, alternateToken = match, malternateMatches = [], currentMatches = matches.slice (), loopNdxCnt = loopNdx.length, altIndex = ndxInitializer.length> 0? ndxInitializer.shift (): -1;
                            if (altIndex === -1 || "string" == typeof altIndex) {
                                var amndx, currentPos = testPos, ndxInitializerClone = ndxInitializer.slice (), altIndexArr = [];
                                if ("string" == typeof altIndex) altIndexArr = altIndex.split (","); else pour (amndx = 0; amndx <alternateToken.matches.length; amndx ++) altIndexArr.push (amndx);
                                for (var ndx = 0; ndx <altIndexArr.length; ndx ++) {
                                    if (amndx = parseInt (altIndexArr [ndx]), correspond = [], ndxInitializer = resolNdxInitializer (testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice (), 
                                    match = handleMatch (alternativeToken.matches [amndx] || masqueToken.matches [amndx], [amndx] .concat (loopNdx), quantifierRecurse) || rencontre,
                                    match! ==! 0 && void 0! == match && altIndexArr [altIndexArr.length - 1] <alternateToken.matches.length) {
                                        var ntndx = $ .inArray (match, maskToken.matches) + 1;
                                        maskToken.matches.length> ntndx && (match = handleMatch (maskToken.matches [ntndx], [ntndx] .concat (loopNdx.slice (1, loopNdx.length)), quantifierRecurse), 
                                        match && (altIndexArr.push (ntndx.toString ()), $ .each (matches, fonction (ndx, lmnt) {
                                            lmnt.alternation = loopNdx.length - 1;
                                        })));
                                    }
                                    maltMatches = matches.slice (), testPos = currentPos, matches = [];
                                    pour (var ndx1 = 0; ndx1 <maltMatches.length; ndx1 ++) {
                                        var altMatch = maltMatches [ndx1], hasMatch =! 1;
                                        altMatch.alternation = altMatch.alternation || loopNdxCnt;
                                        pour (var ndx2 = 0; ndx2 <malternateMatches.length; ndx2 ++) {
                                            var altMatch2 = malternateMatches [ndx2];
                                            if (("string"! = typeof altIndex || $ .inArray (altMatch.locator [altMatch.alternation] .toString (), altIndexArr)! == -1) && (altMatch.match.def === altMatch2.match .def || staticCanMatchDefinition (altMatch, altMatch2))) {
                                                hasMatch = altMatch.match.nativeDef === altMatch2.match.nativeDef, altMatch.alternation == altMatch2.alternation && altMatch2.locator [altMatch2.alternation] .toString (). indexOf (altMatch.locator [altMatch.alternation]) = == -1 && (altMatch2.locator [altMatch2.alternation] = altMatch2.locator [altMatch2.alternation] + "," + altMatch.locator [altMatch.alternation], 
                                                altMatch2.alternation = altMatch.alternation, null == altMatch.match.fn && (altMatch2.na = altMatch2.na || altMatch.locator [altMatch.alternation] .toString (), 
                                                altMatch2.na.indexOf (altMatch.locator [altMatch.alternation]) === -1 && (altMatch2.na = altMatch2.na + "," + altMatch.locator [altMatch.alternation])));
                                                Pause;
                                            }
                                        }
                                        hasMatch || malternateMatches.push (altMatch);
                                    }
                                }
                                "string" == typeofaltIndex && (malternateMatches = $ .map (malternateMatches, function (lmnt, ndx) {{
                                    if (isFinite (ndx)) {
                                        var mamatch, alternance = lmnt.alternation, altLocArr = lmnt.locator [alternance] .toString (). split (",");
                                        lmnt.locator [alternance] = vide 0, lmnt.alternation = vide 0;
                                        pour (var alndx = 0; alndx <altLocArr.length; alndx ++) mamatch = $ .inArray (altLocArr [alndx], altIndexArr)! == -1, 
                                        mamatch && (void 0! == lmnt.locator [alternance]? (lmnt.locator [alternance] + = ",", 
                                        lmnt.locator [alternance] + = altLocArr [alndx]): lmnt.locator [alternance] = parseInt (altLocArr [alndx]), 
                                        lmnt.alternation = alternance);
                                        if (void 0! == lmnt.locator [alternance]) return lmnt;
                                    }
                                })), matches = currentMatches.concat (malternateMatches), testPos = pos, insertStop = matches.length> 0, 
                                ndxInitializer = ndxInitializerClone.slice ();
                            } else match = handleMatch (alternateToken.matches [altIndex] || maskToken.matches [altIndex], [altIndex] .concat (loopNdx), quantifierRecurse);
                            si (match) retourne! 0;
                        } else if (match.isQuantifier && quantifierRecurse! == maskToken.matches [$. inArray (match, maskToken.matches) - 1]) pour (var qt = match, qndx = ndxInitializer.length> 0? ndxInitializer.shift () : 0; qndx <(isNaN (qt.quantifier.max)? Qndx + 1: qt.quantifier.max) && testPos <= pos; qndx ++) {
                            var tokenGroup = maskToken.matches [$. inArray (qt, maskToken.matches) - 1];
                            if (match = handleMatch (tokenGroup, [qndx] .concat (loopNdx), tokenGroup)) {
                                if (latestMatch = correspond à [matches.length - 1] .match, latestMatch.optionalQuantifier = qndx> qt.quantifier.min - 1, 
                                isFirstMatch (latestMatch, tokenGroup)) {
                                    si (qndx> qt.quantifier.min - 1) {
                                        insertStop =! 0, testPos = pos;
                                        Pause;
                                    }
                                    retourner! 0;
                                }
                                retourner! 0;
                            }
                        } else if (match = resolTestFromToken (match, ndxInitializer, loopNdx, quantifierRecurse)) return! 0;
                    } else testPos ++;
                }
                for (var tndx = ndxInitializer.length> 0? ndxInitializer.shift (): 0; tndx <masqueToken.matches.length; tndx ++) if (masqueToken.matches [tndx] .isQuantifier! ==! 0) {
                    var match = handleMatch (maskToken.matches [tndx], [tndx] .concat (loopNdx), quantifierRecurse);
                    if (match && testPos === pos) return match;
                    si (testPos> pos) pause;
                }
            }
            fonction mergeLocators (tests) {
                var locator = [];
                retourne $ .isArray (tests) || (tests = [tests]), tests.length> 0 && (void 0 === teste [0] .alternation? (locator = defineTestTemplate (testss.slice ()). locator.slice (),
                0 === locator.length && (locator = tests [0] .locator.slice ())): $ .each (tests, function (ndx, tst) {
                    if (""! == tst.def) if (0 === locator.length) locator = tst.locator.slice (); else pour (var i = 0; i <locator.length; i ++) tst.locator [i] && locator [i] .toString (). indexOf (tst.locator [i]) === -1 && (locator [ i] + = "," + tst.locator [i]);
                })), localisateur;
            }
            fonction filterTests (tests) {
                return opts.keepStatic && pos> 0 && tests.length> 1 + ("" === teste [tests.length - 1] .match.def? 1: 0) && teste [0] .match.optionality! == ! 0 && teste [0] .match.optionalQuantifier! ==! 0 && null === teste [0] .match.fn &&! / [0-9a-bA-Z] /. Test (teste [0]. match.def)? [DeterminationTestTemplate (tests)]: tests;
            }
            var latestMatch, maskTokens = getMaskSet (). maskToken, testPos = ndxIntlzr? étapes: 0, ndxInitializer = ndxIntlzr? ndxIntlzr.slice (): [0], correspond = [], insertStop =! 1, cacheDependency = ndxIntlzr? ndxIntlzr.join (""): "";
            si (pos> -1) {
                if (void 0 === ndxIntlzr) {
                    for (var test, previousPos = pos - 1; void 0 === (test = getMaskSet (). validPositions [previousPos] || getMaskSet (). tests [previousPos]) && previousPos> -1;) previousPos--;
                    void 0! == test && previousPos> -1 && (ndxInitializer = mergeLocators (test), cacheDependency = ndxInitializer.join (""), 
                    testPos = previousPos);
                }
                if (getMaskSet (). tests [pos] && getMaskSet (). tests [pos] [0] .cd === cacheDependency) renvoie filterTests (getMaskSet (). tests [pos]);
                for (var mtndx = ndxInitializer.shift (); mtndx <maskTokens.length; mtndx ++) {
                    var match = resolTestFromToken (maskTokens [mtndx], ndxInitializer, [mtndx]);
                    if (match && testPos === pos || testPos> pos) break;
                }
            }
            return (0 === matches.length || insertStop) && matches.push ({
                rencontre: {
                    fn: null,
                    cardinalité: 0,
                    optionnel:! 0,
                    boîtier: nul,
                    def: "",
                    espace réservé: ""
                },
                localisateur: [],
                cd: cacheDependency
            }), void 0! == ndxIntlzr && getMaskSet (). tests [pos]? filterTests ($. extend (! 0, [], correspondances)):: (getMaskSet (). tests [pos] = $ .extend (! 0, [], correspondances),
            filterTests (getMaskSet (). tests [pos]));
        }
        fonction getBufferTemplate () {
            return void 0 === getMaskSet () ._ buffer && (getMaskSet () ._ buffer = getMaskTemplate (! 1, 1), 
            void 0 === getMaskSet (). buffer && getMaskSet () ._ buffer.slice ()), getMaskSet () ._ buffer;
        }
        fonction getBuffer (noCache) {
            retourne la valeur 0! == getMaskSet (). buffer && noCache! ==! 0 || (getMaskSet (). buffer = getMaskTemplate (! 0, getLastValidPosition (),! 0)),
            getMaskSet (). buffer;
        }
        fonction refreshFromBuffer (début, fin, tampon) {
            var i;
            si (début ===! 0) resetMaskSet (), début = 0, fin = buffer.length; sinon pour (i = début; i <fin; i ++) supprimer getMaskSet (). validPositions [i];
            pour (i = début; i <fin; i ++) resetMaskSet (! 0), tampon [i]! == opts.skipOptionalPartCharacter && isValid (i, tampon [i],! 0,! 0);
        }
        fonction boîtier (elem, test, pos) {
            commutateur (opts.casing || test.casing) {
              cas "supérieur":
                elem = elem.toUpperCase ();
                Pause;

              cas "inférieur":
                elem = elem.toLowerCase ();
                Pause;

              case "titre":
                var posBefore = getMaskSet (). validPositions [pos - 1];
                elem = 0 === pos || posBefore && posBefore.input === String.fromCharCode (Inputmask.keyCode.SPACE)? elem.toUpperCase (): elem.toLowerCase ();
            }
            renvoyer elem;
        }
        fonction checkAlternationMatch (altArr1, altArr2) {
            pour (var altArrC = opts.greedy? altArr2: altArr2.slice (0, 1), isMatch =! 1, alndx = 0; alndx <0 altArr1.length; alndx ++) si ($ .inArray (altArr1 [alndx], altArrC) ! == -1) {
                isMatch =! 0;
                Pause;
            }
            return isMatch;
        }
        fonction isValid (pos, c, strict, fromSetValid, fromAlternate) {
            fonction isSelection (posObj) {
                var selection = isRTL? posObj.begin - posObj.end> 1 || posObj.begin - posObj.end === 1 && opts.insertMode: posObj.end - posObj.begin> 1 || posObj.end - posObj.begin === 1 && opts.insertMode;
                renvoyer la sélection && 0 === posObj.begin && posObj.end === getMaskSet (). maskLength? "complet": sélection;
            }
            fonction _isValid (position, c, strict) {
                var rslt =! 1;
                retourne $ .each (getTests (position), fonction (ndx, tst) {
                    pour (var test = tst.match, loopend = c? 1: 0, chrs = "", i = test.cardinality; i> loopend; i--) chrs + = getBufferElement (position - (i - 1));
                    if (c && (chrs + = c), getBuffer (! 0), rslt = null! = test.fn? test.fn.test (chrs, getMaskSet (), position, strict, opts, isSelection (pos)): (c === test.def || c === opts.skipOptionalPartCharacter) && ""! == test.def && {
                        c: test.placeholder || test.def,
                        pos: position
                    }, rslt! ==! 1) {
                        var elem = void 0! == rslt.c? rslt.c: c;
                        elem = elem === opts.skipOptionalPartCharacter && null === test.fn? test.placeholder || test.def: elem;
                        var validatedPos = position, possibleModifiedBuffer = getBuffer ();
                        if (void 0! == rslt.remove && ($ .isArray (rslt.remove) || (rslt.remove = [rslt.remove]),), 
                        $ .each (rslt.remove.sort (fonction (a, b) {
                            retourne b - a;
                        }), fonction (ndx, lmnt) {
                            stripValidPositions (lmnt, lmnt + 1,! 0);
                        })), void 0! == rslt.insert && ($ .isArray (rslt.insert) || (rslt.insert = [rslt.insert]), 
                        $ .each (rslt.insert.sort (fonction (a, b) {
                            retourne a - b;
                        }), fonction (ndx, lmnt) {
                            isValid (lmnt.pos, lmnt.c,! 0, fromSetValid);
                        })), rslt.refreshFromBuffer) {
                            var refresh = rslt.refreshFromBuffer;
                            if (strict =! 0, refreshFromBuffer (refresh ===! 0? refresh: refresh.start, refresh.end, possibleModifiedBuffer), 
                            void 0 === rslt.pos && void 0 === rslt.c) renvoie rslt.pos = getLastValidPosition (), 
                            !1;
                            if (validatedPos = void 0! == rslt.pos? rslt.pos: position, validatedPos! == position) renvoie rslt = $ .extend (rslt, isValid (validatedPos, elem,! 0, fromSetValid)), 
                            !1;
                        } else if (rslt! ==! 0 && void 0! == rslt.pos && rslt.pos! == position && (validatedPos = rslt.pos, 
                        refreshFromBuffer (position, validatedPos, getBuffer (). slice ()), validatedPos! == position)) renvoie rslt = $ .extend (rslt, isValid (validatedPos, elem,! 0)), 
                        !1;
                        return (rslt ===! 0 || void 0! == rslt.pos || void 0! == rslt.c) && (ndx> 0 && resetMaskSet (! 0), 
                        setValidPosition (validatedPos, $ .extend ({}, tst, {
                            entrée: boîtier (elem, test, validatedPos)
                        }), fromSetValid, isSelection (pos)) || (rslt =! 1),! 1);
                    }
                }), rslt;
            }
            fonction alternative (pos, c, strict) {
                var lastAlt, alternance, altPos, prevAltPos, i, validPos, altNdxs, decisionPos, validPsClone = $ .extend (! 0, {}, getMaskSet (). validPositions), isValidRslt =! 1, lAltPos = getLastValidPosition ();
                for (prevAltPos = getMaskSet (). validPositions [lAltPos]; lAltPos> = 0; lAltPos--) if (altPos = getMaskSet (). validPositions [lAltPos], 
                altPos && void 0! == altPos.alternation) {
                    if (lastAlt = lAltPos, alternance = getMaskSet (). validPositions [lastAlt] .alternation, 
                    prevAltPos.locator [altPos.alternation]! == altPos.locator [altPos.alternation]) break;
                    prevAltPos = altPos;
                }
                if (void 0! == alternance) {
                    decisionPos = parseInt (lastAlt);
                    var decisionTaker = void 0! == prevAltPos.locator [prevAltPos.alternation || alternance]? prevAltPos.locator [prevAltPos.alternation || alternance]: altNdxs [0];
                    decisionTaker.length> 0 && (decisionTaker = decisionTaker.split (",") [0]);
                    var possibilitéPos = getMaskSet (). validPositions [décisionPos], prevPos = getMaskSet (). validPositions [decisionPos - 1];
                    $ .each (getTests (decisionPos, prevPos? prevPos.locator: vide 0, decisionPos - 1), fonction (ndx, test) {
                        altNdxs = test.locator [alternance]? test.locator [alternance] .toString (). split (","): [];
                        pour (var mndx = 0; mndx <altNdxs.length; mndx ++) {
                            var validInputs = [], staticInputsBeforePos = 0, staticInputsBeforePosAlternate = 0, verifyValidInput =! 1;
                            if (decisionTaker <altNdxs [mndx] && (void 0 === test.na || $ .inArray (altNdxs [mndx], test.na.split (",")) === -1)) {
                                getMaskSet (). validPositions [decisionPos] = $ .extend (! 0, {}, test);
                                var possibilités = getMaskSet (). validPositions [decisionPos] .locator;
                                pour (getMaskSet (). validPositions [décisionPos] .locator [alternation] = parseInt (altNdxs [mndx]), 
                                null == test.match.fn? (possibilitéPos.input! == test.match.def && (verifyValidInput =! 0,
                                possibilitéPos.generatedInput! ==! 0 && validInputs.push (possibilitéPos.input)), 
                                staticInputsBeforePosAlternate ++, getMaskSet (). validPositions [decisionPos] .generatedInput =! / [0-9a-bA-Z] /. test (test.match.def), 
                                getMaskSet (). validPositions [décisionPos] .input = test.match.def): getMaskSet (). validPositions [décisionPos] .input = possibilitéPos.input, 
                                i = décisionPos + 1; i <getLastValidPosition (vide 0,! 0) + 1; i ++) validPos = getMaskSet (). validPositions [i],
                                validPos && validPos.generatedInput! ==! 0 && /[0-9a-bA-Z]/.test(validPos.input)? validInputs.push (validPos.input): i <pos && staticInputsBeforePos ++,
                                delete getMaskSet (). validPositions [i];
                                for (verifyValidInput && validInputs [0] === test.match.def && validInputs.shift (), 
                                resetMaskSet (! 0), isValidRslt =! 0; validInputs.length> 0; ) {
                                    var input = validInputs.shift ();
                                    if (input! == opts.skipOptionalPartCharacter &&! (isValidRslt = isValid (getLastValidPosition (vide 0,! 0) + 1, entrée,! 1, fromSetValid,! 0))) pause;
                                }
                                if (isValidRslt) {
                                    getMaskSet (). validPositions [decisionPos] .locator = possibilités;
                                    var targetLvp = getLastValidPosition (pos) + 1;
                                    pour (i = décisionPos + 1; i <getLastValidPosition () + 1; i ++) validPos = getMaskSet (). validPositions [i], 
                                    (void 0 === validPos || null == validPos.match.fn) && i <pos + (staticInputsBeforePosAlternate - staticInputsBeforePos) && staticInputsBeforePosAlternate ++;
                                    pos + = staticInputsBeforePosAlternate - staticInputsBeforePos, isValidRslt = isValid (pos> targetLvp? targetLvp: pos, c, strict, fromSetValid,! 0);
                                }
                                if (isValidRslt) renvoie! 1;
                                resetMaskSet (), getMaskSet (). validPositions = $ .extend (! 0, {}, validPsClone);
                            }
                        }
                    });
                }
                return isValidRslt;
            }
            fonction trackbackAlternations (originalPos, newPos) {
                var vp = getMaskSet (). validPositions [newPos];
                if (vp) pour (var targetLocator = vp.locator, tll = targetLocator.length, ps = originalPos; ps <newPos; ps ++) if (void 0 === getMaskSet (). validPositions [ps] &&!! isMask (ps, ! 0)) {
                    var tests = getTests (ps), bestMatch = tests [0], égalité = -1;
                    $ .each (tests, function (ndx, tst) {
                        for (var i = 0; i <tll && (void 0! == tst.locat ou [i] && checkAlternationMatch (tst.locator [i] .toString (). split (","), targetLocator [i]. toString (). split (","))); i ++) égalité <i && (égalité = i,
                        bestMatch = tst);
                    }), setValidPosition (ps, $ .extend ({}, bestMatch, {
                        entrée: bestMatch.match.placeholder || bestMatch.match.def
                    }),! 0);
                }
            }
            fonction setValidPosition (pos, validTest, fromSetValid, isSelection) {
                if (isSelection || opts.insertMode && void 0! == getMaskSet (). validPositions [pos] && void 0 === fromSetValid) {
                    var i, positionsClone = $ .extend (! 0, {}, getMaskSet (). validPositions), lvp = getLastValidPosition (void 0,! 0);
                    pour (i = pos; i <= lvp; i ++) supprimez getMaskSet (). validPositions [i];
                    getMaskSet (). validPositions [pos] = $ .extend (! 0, {}, validTest);
                    var j, valide =! 0, vps = getMaskSet (). validPositions, needsValidation =! 1, initialLength = getMaskSet (). maskLength;
                    pour (i = j = pos; i <= lvp; i ++) {
                        var t = positionsClone [i];
                        if (void 0! == t) pour (var posMatch = j; posMatch <getMaskSet (). maskLength && (null == t.match.fn && vps [i] && (vps [i] .match.optionalQuantifier == =! 0 || vps [i] .match.optionality ===! 0) || null! = T.match.fn);) {)
                            if (posMatch ++, needsValidation ===! 1 && positionsClone [posMatch] && positionsClone [posMatch] .match.def === t.match.def) getMaskSet (). validPositions [posMatch] = $ .extend (! 0, { }, positionsClone [posMatch]), 
                            getMaskSet (). validPositions [posMatch] .input = t.input, fillMissingNonMask (posMatch), 
                            j = posMatch, valid =! 0; else if (positionCanMatchDefinition (posMatch, t.match.def)) {
                                var result = isValid (posMatch, t.input,! 0,! 0);
                                valide = résultat! ==! 1, j = result.caret || resultat.insert? getLastValidPosition (): posMatch,
                                needsValidation =! 0;
                            } else valid = t.generatedInput ===! 0;
                            if (getMaskSet (). maskLength <initialLength && (getMaskSet (). maskLength = initialLength), 
                            valide) pause;
                        }
                        si (! valide) pause;
                    }
                    if (! valide) renvoie getMaskSet (). validPositions = $ .extend (! 0, {}, positionsClone), 
                    resetMaskSet (! 0),! 1;
                } else getMaskSet (). validPositions [pos] = $ .extend (! 0, {}, validTest);
                renvoyer resetMaskSet (! 0),! 0;
            }
            fonction fillMissingNonMask (maskPos) {
                for (var pndx = maskPos - 1; pndx> -1 &&! getMaskSet (). validPositions [pndx]; pndx--);
                var testTemplate, testsFromPos;
                for (pndx ++; pndx <maskPos; pndx ++) void 0 === getMaskSet (). validPositions [pndx] && (opts.jitMasking ===! 1 || opts.jitMasking> pndx) && (testsFromPos = getTests (pndx, getTestsTimer) (pndx - 1) .locator, pndx - 1) .slice (), 
                "" === testsFromPos [testsFromPos.length - 1] .match.def && testsFromPos.pop (), testTemplate = DetermTestTemplate (testsFromPos), 
                testTemplate && (testTemplate.match.def === opts.radixPointDefinitionSymbol ||! isMask (pndx,! 0) || $ .inArray (opts.radixPoint, getBuffer ()) <pndx && testTemplate.match.fn && testTemplate.match .fn.test (getPlaceholder (pndx), getMaskSet (), pndx,! 1, opts)) && (result = _isValid (pndx, testTemplate.match.placeholder || (null == testTemplate.match.fn? testTemplate.match .def: ""! == getPlaceholder (pndx)? getPlaceholder (pndx): getBuffer () [pndx]),! 0), 
                result! ==! 1 && (getMaskSet (). validPositions [result.pos || pndx] .generatedInput =! 0)));
            }
            strict = strict ===! 0;
            var maskPos = pos;
            void 0! == pos.begin && (maskPos = isRTL &&! isSelection (pos)? pos.end: pos.begin);
            var result =! 1, positionsClone = $ .extend (! 0, {}, getMaskSet (). validPositions);
            if (fillMissingNonMask (maskPos), isSelection (pos) && (handleRemove (vide 0, Inputmask.keyCode.DELETE, pos), 
            maskPos = getMaskSet (). p), maskPos <getMaskSet (). maskLength && (result = _isValid (maskPos, c, strict), 
            (! strict || fromSetValid ===! 0) && result ===! 1)) {
                var currentPosValid = getMaskSet (). validPositions [maskPos];
                if (! currentPosValid || null! == currentPosValid.match.fn || currentPosValid.match.def! == c && c! == opts.skipOptionalPartCharacter) {
                    if ((opts.insertMode || void 0 === getMaskSet (). validPositions [seekNext (maskPos)]) &&! isMask (maskPos,! 0)) {
                        var testsFromPos = getTests (maskPos) .slice ();
                        "" === testsFromPos [testsFromPos.length - 1] .match.def && testsFromPos.pop ();
                        var staticChar = DetermineTestTemplate (testsFromPos,! 0);
                        staticChar && null === staticChar.match.fn && (staticChar = staticChar.match.placeholder || staticChar.match.def, 
                        _isValid (maskPos, staticChar, strict), getMaskSet (). validPositions [maskPos] .generatedInput =! 0);
                        pour (var nPos = maskPos + 1, snPos = seekNext (maskPos); nPos <= snPos; nPos ++) if (résultat = _isValid (nPos, c, strict), 
                        résultat! ==! 1) {
                            trackbackAlternations (maskPos, void 0! == result.pos? result.pos: nPos), maskPos = nPos;
                            Pause;
                        }
                    }
                } else result = {
                    caret: seekNext (maskPos)
                };
            }
            renvoyer le résultat ===! 1 && opts.keepStatic &&! strict && fromAlternate! ==! 0 && (result = alternative (maskPos, c, strict)), 
            résultat ===! 0 && (result = {
                pos: maskPos
            }), $ .isFunction (opts.postValidation) && result! ==! 1 &&! strict && fromSetValid! ==! 0 && (result = !! opts.postValidation (getBuffer (! 0), result, optts) && result ), 
            void 0 === result.pos && (result.pos = maskPos), result ===! 1 && (resetMaskSet (! 0), 
            getMaskSet (). validPositions = $ .extend (! 0, {}, positionsClone)), résultat;
        }
        fonction isMask (pos, strict) {
            test var;
            if (strict? (test = getTestTemplate (pos) .match, "" === test.def && (test = getTest (pos) .match)): test = getTest (pos) .match, 
            null! = test.fn) renvoie test.fn;
            if (strict! ==! 0 && pos> -1) {
                var tests = getTests (pos);
                return tests.length> 1 + ("" === tests [tests.length - 1] .match.def? 1: 0);
            }
            retourner! 1;
        }
        fonction seekNext (pos, newBlock) {
            var maskL = getMaskSet (). maskLength;
            if (pos> = maskL) renvoie maskL;
            for (var position = pos; ++ position <maskL && (newBlock ===! 0 && (getTest (position) .match.newBlockMarker! ==! 0 ||! isMask (position)) || newBlock! ==! 0 &&! IsMask (position)););
            position de retour;
        }
        fonction seekPrevious (pos, newBlock) {
            var tests, position = pos;
            if (position <= 0) renvoie 0;
            pour (; - position> 0 && (newBlock ===! 0 && getTest (position) .match.newBlockMarker! ==! 0 || newBlock! ==! 0 &&! isMask (position) && (tests = getTests ( position), 
            tests.length <2 || 2 === tests.length && "" === tests [1] .match.def)); )
            position de retour;
        }
        fonction getBufferElement (position) {
            return void 0 === getMaskSet (). validPositions [position]? getPlaceholder (position): getMaskSet (). validPositions [position] .input;
        }
        function writeBuffer (entrée, tampon, caretPos, événement, triggerInputEvent) {
            if (événement && $ .isFunction (opts.onBeforeWrite)) {
                var result = opts.onBeforeWrite (event, buffer, caretPos, opts);
                si (résultat) {
                    if (result.refreshFromBuffer) {
                        var refresh = result.refreshFromBuffer;
                        refreshFromBuffer (refresh ===! 0? refresh: refresh.start, refresh.end, result.buffer || buffer), 
                        tampon = getBuffer (! 0);
                    }
                    void 0! == caretPos && (caretPos = void 0! == result.caret? result.caret: caretPos);
                }
            }
            input.inputmask._valueSet (buffer.join ("")), void 0 === caretPos || void 0! == event && "blur" === event.type? renderColorMask (input, buffer, caretPos): caret (entrée, caretPos),
            triggerInputEvent ===! 0 && (skipInputEvent =! 0, $ (entrée) .trigger ("entrée"));
        }
        fonction getPlaceholder (pos, test) {
            if (test = test || getTest (pos) .match, annule 0! == test.placeholder) renvoie test.placeholder;
            if (null === test.fn) {
                if (pos> -1 && void 0 === getMaskSet (). validPositions [pos]) {
                    var prevTest, tests = getTests (pos), staticAlternations = [];
                    if (tests.length> 1 + ("" === teste [tests.length - 1] .match.def? 1: 0)) pour (var i = 0; i <tests.length; i ++) si (teste [i] .match.optionality! ==! 0 && teste [i] .match.optionalQuantifier! ==! 0 && (null === teste [i] .match.fn || void 0 === prevTest || tests [i] .match.fn.test (prevTest.match.def, getMaskSet (), pos,! 0, opts)! ==! 1) && (staticAlternations.push (tests [i]), 
                    null === teste [i] .match.fn && (prevTest = teste [i]), staticAlternations.length> 1 && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def ))) return opts.placeholder.charAt (pos% opts.placeholder.length);
                }
                retourner test.def;
            }
            return opts.placeholder.charAt (pos% opts.placeholder.length);
        }
        function checkVal (entrée, writeOut, strict, nptvl, initerringEvent, stickyCaret) {
            fonction isTemplateMatch () {
                var isMatch =! 1, charCodeNdx = getBufferTemplate (). slice (initialNdx, seekNext (initialNdx)). join (""). indexOf (charCodes);
                if (charCodeNdx! == -1 &&! isMask (initialNdx)) {
                    isMatch =! 0;
                    for (var bufferTemplateArr = getBufferTemplate (). slice (initialNdx, initialNdx + ​​charCodeNdx), i = 0; i <bufferTemplateArr.length; i ++) if (""! == bufferTemplateArr) i
                        isMatch =! 1;
                        Pause;
                    }
                }
                return isMatch;
            }
            var inputValue = nptvl.slice (), charCodes = "", initialNdx = 0, result = void 0;
            if (resetMaskSet (), getMaskSet (). p = seekNext (-1),! strict) if (opts.autoUnmask! ==! 0) {
                var staticInput = getBufferTemplate (). slice (0, seekNext (-1)). join (""), correspond à = inputValue.join (""). match (nouveau RegExp ("^" + Inputmask.escapeRegex (staticInput), "g"));
                matches && matches.length> 0 && (inputValue.splice (0, matches.length * staticInput.length), 
                initialNdx = seekNext (initialNdx));
            } else initialNdx = seekNext (initialNdx);
            if ($ .each (inputValue, function (ndx, charCode)) {
                if (void 0! == charCode) {
                    var keypress = new $ .Event ("keypress");
                    appuyez sur la touche.which = charCode.charCodeAt (0), charCodes + = charCode;
                    var lvp = getLastValidPosition (vide 0,! 0), lvTest = getMaskSet (). validPositions [lvp], nextTest = getTestTemplate (lvp + 1, lvTest? lvTest.locator.slice (): void 0, lvp);
                    if (! isTemplateMatch () || strict || opts.autoUnmask) {
                        var pos = strict? ndx: null == nextTest.match.fn && nextTest.match.optionality && lvp + 1 <getMaskSet (). p? lvp + 1: getMaskSet (). p;
                        result = keypressEvent.call (entrée, pression de touche,! 0,! 1, strict, pos), initialNdx = pos + 1, 
                        charCodes = "";
                    } else result = keypressEvent.call (entrée, pression de touche,! 0,! 1,! 0, lvp + 1);
                    if (! strict && $ .isFunction (opts.onBeforeWrite) && (result = opts.onBeforeWrite (appuyez sur la touche, getBuffer (), result.forwardPosition, opts), 
                    result && result.refreshFromBuffer)) {
                        var refresh = result.refreshFromBuffer;
                        refreshFromBuffer (refresh ===! 0? refresh: refresh.start, refresh.end, result.buffer), 
                        resetMaskSet (! 0), result.caret && (getMaskSet (). p = result.caret);
                    }
                }
            }), rédiger) {
                var caretPos = vide 0, lvp = getLastValidPosition ();
                document.activeElement === input && (initiatedEvent || result) && (caretPos = caret (input) .begin, 
                initiatedEvent && result ===! 1 && (caretPos = seekNext (getLastValidPosition (caretPos))), 
                result && stickyCaret! ==! 0 && (caretPos <lvp + 1 || lvp === -1) && (caretPos = opts.numericInput && void 0 === result.caret? seekPrevious (result.forwardPosition): result. forwardPosition)), 
                writeBuffer (input, getBuffer (), caretPos, initiatedEvent || new $ .Event ("checkval"));
            }
        }
        function unmaskedvalue (input) {
            if (input && void 0 === input.inputmask) renvoie input.value;
            var umValue = [], vps = getMaskSet (). validPositions;
            pour (var pndx dans vps) vps [pndx] .match && null! = vps [pndx] .match.fn && umValue.push (vps [pndx] .input);
            var unmaskedValue = 0 === umValue.length? "": (isRTL? umValue.reverse (): umValue) .join ("");
            if ($ .isFunction (opts.onUnMask)) {
                var bufferValue = (isRTL? getBuffer (). slice (). reverse (): getBuffer ()). join ("");
                unmaskedValue = opts.onUnMask (bufferValue, unmaskedValue, opts) || unmaskedValue;
            }
            return unmaskedValue;
        }
        fonction caret (entrée, début, fin, non traduite) {
            fonction translatePosition (pos) {
                if (notranslate! ==! 0 && isRTL && "numéro" == typeof pos && (! opts.greedy || ""! == opts.placeholder)) {
                    var bffrLght = getBuffer (). join (""). length;
                    pos = bffrLght - pos;
                }
                retour pos;
            }
            gamme var;
            if ("number"! = typeof begin) renvoie input.setSelectionRange? (begin = input.selectionStart,
            end = input.selectionEnd): window.getSelection? (range = window.getSelection (). getRangeAt (0),
            range.commonAncestorContainer.parentNode! == entrée && range.commonAncestorContainer! == input || (begin = range.startOffset,
            end = range.endOffset)): document.selection && document.selection.createRange && (range = document.selection.createRange (), 
            begin = 0 - range.duplicate (). moveStart ("character", -input.inputmask._valueGet (). length), 
            end = begin + range.text.length), {
                commencer: translatePosition (commencer),
                fin: translatePosition (fin)
            };
            begin = translatePosition (begin), end = translatePosition (end), end = "number" == typeof end? fin: commencer;
            var scrollCalc = parseInt (((input.ownerDocument.defaultView || fenêtre) .getComputedStyle? (input.ownerDocument.defaultView || fenêtre) .getComputedStyle (entrée, null): input.currentStyle) .fontSize) .fontSize) * end;
            if (input.scrollLeft = scrollCalc> input.scrollWidth? scrollCalc: 0, mobile || opts.insertMode! ==! 1 || begin! == end || end ++, 
            input.setSelectionRange) input.selectionStart = begin, input.selectionEnd = end; else if (window.getSelection) {
                if (range = document.createRange (), void 0 === input.firstChild || null === input.firstChild) {
                    var textNode = document.createTextNode ("");
                    input.appendChild (textNode);
                }
                range.setStart (input.firstChild, begin <input.inputmask._valueGet (). length? begin: input.inputmask._valueGet (). length), 
                range.setEnd (input.firstChild, end <input.inputmask._valueGet (). length? end: input.inputmask._valueGet (). length), 
                range.collapse (! 0);
                var sel = window.getSelection ();
                sel.removeAllRanges (), sel.addRange (plage);
            } else input.createTextRange && (range = input.createTextRange (), range.collapse (! 0), 
            range.moveEnd ("character", end), range.moveStart ("character", begin), range.select ());
            renderColorMask (input, void 0, {
                commencer: commencer,
                fin: fin
            });
        }
        function DetermineLastRequiredPosition (returnDefinition) {
            var pos, testPos, buffer = getBuffer (), bl = buffer.length, lvp = getLastValidPosition (), positions = {}, lvTest = getMaskSet (). validPositions [lvp], ndxIntlzr = void 0! == lvTest? lvTest.locator.slice (): vide 0;
            pour (pos = lvp + 1; pos <buffer.length; pos ++) testPos = getTestTemplate (pos, ndxIntlzr, pos - 1), 
            ndxIntlzr = testPos.locator.slice (), positions [pos] = $ .extend (! 0, {}, testPos);
            var lvTestAlt = lvTest && void 0! == lvTest.alternation? lvTest.locator [lvTest.alternation]: vide 0;
            pour (pos = bl - 1; pos> lvp && (testPos = positions [pos], (testPos.match.optionality || testPos.match.optionalQuantifier || lvTestAlt && (lvTestAlt! == positions [pos] .locator [lvTest .alternation] && null! = testPos.match.fn || null === testPos.match.fn && testPos.locator [lvTest.alternation] && checkAlternationMatch (testPos.locator [lvTest.alternation] .toString (). ","), lvTestAlt.toString (). split (",")) && ""! == getTests (pos) [0] .def)) && buffer [pos] === getPlaceholder (pos, testPos.match ));; pos--) bl--;
            return returnDefinition? {
                l: bl,
                def: positions [bl]? positions [bl] .match: vide 0
            }: bl;
        }
        fonction clearOptionalTail (tampon) {
            for (var rl = determineLastRequiredPosition (), lmib = buffer.length - 1; lmib> rl &&! isMask (lmib); lmib--);
            return buffer.splice (rl, lmib + 1 - rl), tampon;
        }
        fonction isComplete (tampon) {
            if ($ .isFunction (opts.isComplete)) renvoie opts.isComplete (tampon, opts);
            if ("*"! == opts.repeat) {
                var complete =! 1, lrp = DetermineLastRequiredPosition (! 0), aml = seekPrevious (lrp.l);
                if (void 0 === lrp.def || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) ​​{
                    complet =! 0;
                    pour (var i = 0; i <= aml; i ++) {
                        var test = getTestTemplate (i) .match;
                        if (null! == test.fn && void 0 === getMaskSet (). validPositions [i] && test.optionality! ==! 0 && test.optionalQuantifier! ==! 0 || null === test.fn && buffer [i]! == getPlaceholder (i, test)) {
                            complet =! 1;
                            Pause;
                        }
                    }
                }
                retour complet;
            }
        }
        fonction patchValueProperty (npt) {
            fonction patchValhook (type) {
                if ($ .valHooks && (void 0 === $ .valHooks [type] || $ .valHooks [type] .inputmaskpatch! ==! 0)) {
                    var valhookGet = $ .valHooks [type] && $ .valHooks [type] .get? $ .valHooks [type] .get: fonction (elem) {
                        return elem.value;
                    }, valhookSet = $ .valHooks [type] && $ .valHooks [type] .set? $ .valHooks [type] .set: fonction (elem, valeur) {
                        return elem.value = valeur, elem;
                    };
                    $ .valHooks [type] = {
                        get: function (elem) {
                            if (elem.inputmask) {
                                if (elem.inputmask.opts.autoUnmask) renvoie elem.inputmask.unmaskedvalue ();
                                var result = valhookGet (elem);
                                return getLastValidPosition (annulation 0, annulation 0, elem.inputmask.maskset.validPositions)! == -1 || opts.nullable! ==! 0? résultat : "";
                            }
                            retourne valhookGet (elem);
                        },
                        set: fonction (elem, valeur) {
                            résultat var, $ elem = $ (elem);
                            return result = valhookSet (elem, valeur), elem.inputmask && $ elem.trigger ("setvalue"), 
                            résultat;
                        },
                        inputmaskpatch:! 0
                    };
                }
            }
            fonction getter () {
                renvoyer this.inputmask? this.inputmask.opts.autoUnmask? this.inputmask.unmaskedvalue (): getLastValidPosition ()! == -1 || opts.nullable! ==! 0? document.activeElement === this && opts.clearMaskOnLostFocus? (isRTL? clearOptionalTail (getBuffer (). slice ()). reverse (): clearOptionalTail (getBuffer (). slice ())). join (""): valueGet.call (this): "": valueGet.call ( ce);
            }
            fonction de réglage (valeur) {
                valueSet.call (this, value), this.inputmask && $ (this) .trigger ("setvalue");
            }
            fonction installNativeValueSetFallback (npt) {
                EventRuler.on (npt, "mouseenter", fonction (événement) {
                    var $ input = $ (this), input = this, value = input.inputmask._valueGet ();
                    valeur! == getBuffer (). join ("") && $ input.trigger ("setvalue");
                });
            }
            var valueGet, valueSet;
            if (! npt.inputmask .__ valueGet) {
                if (opts.noValuePatching! ==! 0) {
                    if (Object.getOwnPropertyDescriptor) {
                        "fonction"! = typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" == typeof "test" .__ proto__? function (object) {
                            retourne l'objet .__ proto__;
                        }: fonction (objet) {
                            return object.constructor.prototype;
                        });
                        var valueProperty = Object.getPrototypeOf? Object.getOwnPropertyDescriptor (Object.getPrototypeOf (npt), "valeur"): void 0;
                        valueProperty && valueProperty.get && valueProperty.set? (valueGet = valueProperty.get,
                        valueSet = valueProperty.set, Object.defineProperty (npt, "valeur", {
                            get: getter,
                            set: setter,
                            configurable:! 0
                        })): "INPUT"! == npt.tagName && (valueGet = function () {
                            return this.textContent;
                        }, valueSet = function (valeur) {
                            this.textContent = valeur;
                        }, Object.defineProperty (npt, "valeur", {
                            get: getter,
                            set: setter,
                            configurable:! 0
                        }));
                    } else document .__ lookupGetter__ && npt .__ lookupGetter __ ("valeur") && (valueGet = npt .__ lookupGetter __ ("valeur"), 
                    valueSet = npt .__ lookupSetter __ ("valeur"), npt .__ defineGetter __ ("valeur", getter), 
                    npt .__ defineSetter __ ("value", séparateur));
                    npt.inputmask .__ valueGet = valueGet, npt.inputmask .__ valueSet = valueSet;
                }
                npt.inputmask._valueGet = function (overruleRTL) {
                    return isRTL && overruleRTL! ==! 0? valueGet.call (this.el) .split (""). reverse (). join (""): valueGet.call (this.el);
                }, npt.inputmask._valueSet = function (valeur, overruleRTL) {
                    valueSet.call (this.el, null === valeur || void 0 === valeur? "": overruleRTL! ==! 0 && isRTL? value.split (""). reverse (). join ("" ) : valeur);
                }, void 0 === valueGet && (valueGet = function () {
                    renvoyer this.value;
                }, valueSet = function (valeur) {
                    this.value = valeur;
                }, patchValhook (npt.type), installNativeValueSetFallback (npt));
            }
        }
        fonction handleRemove (entrée, k, pos, strict) {
            fonction generalize () {
                if (opts.keepStatic) {
                    for (var validInputs = [], lastAlt = getLastValidPosition (-1,! 0), positionsClone = $ .extend (! 0, {}, getMaskSet (). validPositions), prevAltPos = getMaskSet (). validPositions [lastAlt]; lastAlt > = 0; lastAlt--) {
                        var altPos = getMaskSet (). validPositions [lastAlt];
                        si (altPos) {
                            if (altPos.generatedInput! ==! 0 && /[0-9a-bA-Z]/.test(altPos.input) && validInputs.push (altPos.input), 
                            delete getMaskSet (). validPositions [lastAlt], void 0! == altPos.alternation && altPos.locator [altPos.alternation]! == prevAltPos.locator [altPos.alternation]) break;
                            prevAltPos = altPos;
                        }
                    }
                    if (lastAlt> -1) pour (getMaskSet (). p = seekNext (getLastValidPosition (-1,! 0)); validInputs.length> 0;) {
                        var keypress = new $ .Event ("keypress");
                        appuyez sur la touche.which = validInputs.pop (). charCodeAt (0), appuyez sur la touche keypressEvent.call (entrée, pression du clavier,! 0,! 1,! 1, getMaskSet (). p);
                    } else getMaskSet (). validPositions = $ .extend (! 0, {}, positionsClone);
                }
            }
            if ((opts.numericInput || isRTL) && (k === Inputmask.keyCode.BACKSPACE? k = Inputmask.keyCode.DELETE: k === Inputmask.keyCode.DELETE && (k = Inputmask.keyCode.BACKSPACE), 
            isRTL)) {
                var pend = pos.end;
                pos.end = pos.begin, pos.begin = pend;
            }
            k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin <1 || opts.insertMode ===! 1)? (pos.begin = seekPrevious (pos.begin),
            void 0 === getMaskSet (). validPositions [pos.begin] || getMaskSet (). validPositions [pos.begin] .input! == opts.groupSeparator && getMaskSet (). validPositions [pos.begin] .input! == opts.radixPoint || pos.begin--): k === Inputmask.keyCode.DELETE && pos.begin === pos.end && (pos.end = isMask (pos.end,! 0)? pos.end + 1: seekNext ( pos.end) + 1,
            void 0 === getMaskSet (). validPositions [pos.begin] || getMaskSet (). validPositions [pos.begin] .input! == opts.groupSeparator && getMaskSet (). validPositions [pos.begin] .input! == opts.radixPoint || pos.end ++),
            stripValidPositions (pos.begin, pos.end,! 1, strict), strict! ==! 0 && generalize ();
            var lvp = getLastValidPosition (pos.begin,! 0);
            lvp <pos.begin? getMaskSet (). p = seekNext (lvp): strict! ==! 0 && (getMaskSet (). p = pos.begin);
        }
        fonction keydownEvent (e) {
            fonction isInputEventSupported (eventName) {
                var el = document.createElement ("input"), evName = "on" + eventName, isSupported = evName dans el;
                return isSupported || (el.setAttribute (evName, "return;"), isSupported = "function" == typeof el [evName]),
                el = null, isSupported;
            }
            entrée var = ceci, $ input = (entrée) $, k = e.keyCode, pos = caret (entrée);
            if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI || e.ctrlKey && k === Inputmask.keyCode.X &&! isInputEventSupported ( "cut")) e.preventDefault (), 
            handleRemove (input, k, pos), writeBuffer (input, getBuffer (! 0), getMaskSet (). p, e, input.inputmask._valueGet ()! == getBuffer (). join ("")), 
            input.inputmask._valueGet () === getBufferTemplate (). join ("")? $ input.trigger ("effacé"): isComplete (getBuffer ()) ===! 0 && $ input.trigger ("complete"),
            opts.showTooltip && (input.title = opts.tooltip || getMaskSet (). mask); else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) {
                e.preventDefault ();
                var caretPos = seekNext (getLastValidPosition ());
                opts.insertMode || caretPos! == getMaskSet (). maskLength || e.shiftKey || caretPos--,
                caret (entrée, e.shiftKey? pos.begin: caretPos, caretPos,! 0);
            } else k === Inputmask.keyCode.HOME &&! e.shiftKey || k === Inputmask.keyCode.PAGE_UP? (e.preventDefault (),
            caret (input, 0, e.shiftKey? pos.begin: 0,! 0)): (opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE || 90 === k && e.ctrlKey) && e. altKey! ==! 0? (checkVal (entrée,! 0,! 1, undoValue.split (""))),
            $ input.trigger ("click")): k! == Inputmask.keyCode.INSERT || e.shiftKey || e.ctrlKey? opts.tabThrough ===! 0 && k === Inputmask.keyCode.TAB? (e.shiftKey ===! 0? (null === getTest (pos.begin) .match.fn && (pos.begin = seekNext (pos.begin)),
            pos.end = seekPrevious (pos.begin,! 0), pos.begin = seekPrevious (pos.end,! 0)): (pos.begin = seekNext (pos.begin,! 0), 
            pos.end = seekNext (pos.begin,! 0), pos.end <getMaskSet (). maskLength && pos.end--), 
            pos.begin <getMaskSet (). maskLength && (e.preventDefault (), caret (entrée, pos.begin, pos.end))): e.shiftKey || (opts.insertMode ===! 1? k === Inputmask.keyCode.RIGHT? setTimeout (function () {
                var caretPos = caret (entrée);
                caret (entrée, caretPos.begin);
            }, 0): k === Inputmask.keyCode.LEFT && setTimeout (function () {
                var caretPos = caret (entrée);
                caret (entrée, isRTL? caretPos.begin + 1: caretPos.begin - 1);
            }, 0): setTimeout (function () {
                renderColorMask (input);
            }, 0)): (opts.insertMode =! Opts.insertMode, caret (entrée, opts.insertMode || pos.begin! == getMaskSet (). MaskLength? Pos.begin: pos.begin - 1));
            opts.onKeyDown.call (this, e, getBuffer (), caret (entrée) .begin, opts), ignorable = $ .inArray (k, opts.ignorables)! == -1;
        }
        fonction keypressEvent (e, checkval, writeOut, strict, ndx) {
            var input = this, $ input = $ (input), k = e.which || e.charCode || e.keyCode;
            if (! (checkval ===! 0 || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable)) renvoie k === Inputmask.keyCode.ENTER && undoValue! == getBuffer (). join ("") && (undoValue = getBuffer (). join (""), 
            setTimeout (function () {
                $ input.trigger ("change");
            }, 0)),! 0;
            si (k) {
                46 === k && e.shiftKey ===! 1 && "," === opts.radixPoint && (k = 44);
                var forwardPosition, pos = checkval? {
                    begin: ndx,
                    fin: ndx
                }: caret (entrée), c = String.fromCharCode (k);
                getMaskSet (). writeOutBuffer =! 0;
                var valResult = isValid (pos, c, strict);
                if (valResult! ==! 1 && (resetMaskSet (! 0), forwardPosition = void 0! == valResult.caret? valResult.caret: checkval? valResult.pos + 1: seekNext (valResult.pos), 
                getMaskSet (). p = forwardPosition), writeOut! ==! 1) {
                    var self = this;
                    if (setTimeout (function () {
                        opts.onKeyValidation.call (self, k, valResult, opts);
                    }, 0), getMaskSet (). WriteOutBuffer && valResult! ==! 1) {
                        var buffer = getBuffer ();
                        writeBuffer (input, buffer, opts.numericInput && void 0 === valResult.caret? seekPrevious (forwardPosition): forwardPosition, e, checkval! ==! 0), 
                        checkval! ==! 0 && setTimeout (function () {
                            isComplete (buffer) ===! 0 && $ input.trigger ("complete");
                        }, 0);
                    }
                }
                if (opts.showTooltip && (input.title = opts.tooltip || getMaskSet (). mask), e.preventDefault (), 
                checkval) return valResult.forwardPosition = forwardPosition, valResult;
            }
        }
        function pasteEvent (e) {
            var tempValue, input = this, ev = e.originalEvent || e, $ input = $ (input), inputValue = input.inputmask._valueGet (! 0), caretPos = caret (input);
            isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue);
            var valueBeforeCaret = inputValue.substr (0, caretPos.begin), valueAfterCaret = inputValue.substr (caretPos.end, inputValue.length);
            if (valueBeforeCaret === (isRTL? getBufferTemplate (). reverse (): getB ufferTemplate ()). slice (0, caretPos.begin) .join ("") && (valueBeforeCaret = ""),
            valueAfterCaret === (isRTL? getBufferTemplate (). reverse (): getBufferTemplate ()). slice (caretPos.end) .join ("") && (valueAfterCaret = ""), 
            isRTL && (tempValue = valueBeforeCaret, valueBeforeCaret = valueAfterCaret, valueAfterCaret = tempValue), 
            window.clipboardData && window.clipboardData.getData) inputValue = valueBeforeCaret + window.clipboardData.getData ("Text") + valueAfterCaret; autre {
                if (! ev.clipboardData ||! ev.clipboardData.getData) return! 0;
                inputValue = valueBeforeCaret + ev.clipboardData.getData ("text / plain") + valueAfterCaret;
            }
            var pasteValue = inputValue;
            if ($ .isFunction (opts.onBeforePaste)) {
                if (pasteValue = opts.onBeforePaste (inputValue, opts), pasteValue ===! 1) renvoie e.preventDefault ();
                pasteValue || (pasteValue = inputValue);
            }
            return checkVal (input,! 1,! 1, isRTL? pasteValue.split (""). reverse (): pasteValue.toString (). split ("")), 
            writeBuffer (input, getBuffer (), seekNext (getLastValidPosition ()), e, undoValue! == getBuffer (). join ("")), 
            isComplete (getBuffer ()) ===! 0 && $ input.trigger ("complete"), e.preventDefault ();
        }
        fonction inputFallBackEvent (e) {
            var input = this, inputValue = input.inputmask._valueGet ();
            if (getBuffer (). join ("")! == inputValue) {
                var caretPos = caret (entrée);
                if (inputValue = inputValue.replace (new RegExp ("(" + Inputmask.escapeRegex), getBufferTemplate (). join ("")) + +)) "," "), 
                iemobile) {
                    var inputChar = inputValue.replace (getBuffer (). join (""), "");
                    if (1 === inputChar.length) {
                        var keypress = new $ .Event ("keypress");
                        retour keypress.which = inputChar.charCodeAt (0), keypressEvent.call (entrée, keypress, 0, 0, 1, getMaskSet () [validPositions caretPos.begin - 1] caretPos.begin:!.? caretPos.begin - 1), 
                        !1;
                    }
                }
                if (caretPos.begin> inputValue.length && (caret (entrée, inputValue.length), caretPos = caret (entrée)), 
                getBuffer (). length - inputValue.length! == 1 || inputValue.charAt (caretPos.begin) === getBuffer () [caretPos.begin] || inputValue.charAt (caretPos.begin + 1) === getBuffer () [caretPos.begin] || isMask (caretPos.begin)) {
                    for (var lvp = getLastValidPosition () + 1, bufferTemplate = getBufferTemplate (). join (""); null === inputValue.match (Inputmask.escapeRex (bufferTemplate) + "$");) bufferTemplate = bufferTemplate.slice ( 1);
                    inputValue = inputValue.replace (bufferTemplate, ""), inputValue = inputValue.split (""), 
                    checkVal (input,! 0,! 1, inputValue, e, caretPos.begin <lvp), isComplete (getBuffer ()) ===! 0 && $ (input) .trigger ("complete");
                } else e.keyCode = Inputmask.keyCode.BACKSPACE, keydownEvent.call (entrée, e);
                e.preventDefault ();
            }
        }
        fonction setValueEvent (e) {
            var input = this, value = input.inputmask._valueGet ();
            checkVal (entrée,! 0,! 1, ($ .isFunction (opts.onBeforeMask)?? opts.onBeforeMask (valeur, opts) || valeur: valeur) .split ("")), 
            undoValue = getBuffer (). join (""), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet () === getBufferTemplate (). join ("") && input.inputmask._valueSet (" ");
        }
        fonction focusEvent (e) {
            var input = this, nptValue = input.inputmask._valueGet ();
            opts.showMaskOnFocus && (! opts.showMaskOnHover || opts.showMaskOnHover && "" === nptValue) && (input.inputmask._valueGet ()! == getBuffer (). rejoindre ("")? écrire (","? ), seekNext (getLastValidPosition ())): mouseEnter ===! 1 && caret (entrée, seekNext (getLastValidPosition ()))), 
            opts.positionCaretOnTab ===! 0 && setTimeout (function () {
                clickEvent.apply (this, [e]);
            }, 0), undoValue = getBuffer (). Join ("");
        }
        function mouseleaveEvent (e) {
            var input = this;
            if (mouseEnter =! 1, opts.clearMaskOnLostFocus && document.activeElement! == entrée) {
                var buffer = getBuffer (). slice (), nptValue = input.inputmask._valueGet ();
                nptValue! == input.getAttribute ("placeholder") && ""! == nptValue && (getLastValidPosition () = )== -1 && nptValue === getBufferTemplate (). join ("")? buffer = []: clearOptionalTail (tampon), 
                writeBuffer (entrée, tampon));
            }
        }
        fonction clickEvent (e) {
            fonction doRadixFocus (clickPos) {
                if (""! == opts.radixPoint) {
                    var vps = getMaskSet (). validPositions;
                    if (void 0 === vps [clickPos] || vps [clickPos] .input === getPlaceholder (clickPos)) {
                        if (clickPos <seekNext (-1)) return! 0;
                        var radixPos = $ .inArray (opts.radixPoint, getBuffer ());
                        if (radixPos! == -1) {
                            pour (var vp in vps) if (radixPos <vp && vps [vp] .input! == getPlaceholder (vp)) return! 1;
                            retourner! 0;
                        }
                    }
                }
                retourner! 1;
            }
            var input = this;
            setTimeout (function () {
                if (document.activeElement === input) {
                    var selectedCaret = caret (entrée);
                    if (selectedCaret.begin === selectedCaret.end) commutateur (opts.positionCaretOnClick) {
                      cas "aucun":
                        Pause;

                      cas "radixFocus":
                        if (doRadixFocus (selectedCaret.begin)) {
                            var radixPos = $ .inArray (opts.radixPoint, getBuffer (). join (""));
                            caret (input, opts.numericInput? seekNext (radixPos): radixPos);
                            Pause;
                        }

                      défaut:
                        var clickPosition = selectedCaret.begin, lvclickPosition = getLastValidPosition (clickPosition,! 0), lastPosition = seekNext (lvclickPosition);
                        if (clickPosition <lastPosition) caret (entrée, isMask (clickPosition) || isMask (clickPosition - 1)? clickPosition: seekNext (clickPosition)); autre {
                            var placeholder = getPlaceholder (lastPosition);
                            (""! == placeholder && getBuffer () [lastPosition]! == placeholder && getTest (lastPosition) .match.optionalQuantifier! ==! 0 ||! isMask (lastPosition) && getTest (lastPosition) .match.def == = espace réservé) && (lastPosition = seekNext (lastPosition)), 
                            caret (entrée, lastPosition);
                        }
                    }
                }
            }, 0);
        }
        fonction dblclickEvent (e) {
            var input = this;
            setTimeout (function () {
                caret (entrée, 0, seekNext (getLastValidPosition ()));
            }, 0);
        }
        fonction cutEvent (e) {
            var input = this, $ input = $ (input), pos = caret (input), ev = e.originalEvent || e, clipboardData = window.clipboardData || ev.clipboardData, clipData = isRTL? getBuffer (). slice (pos.end, pos.begin): getBuffer (). slice (pos.begin, pos.end);
            clipboardData.setData ("text", isRTL? clipData.reverse (). join (""): clipData.join ("")), 
            document.execCommand && document.execCommand ("copy"), handleRemove (input, Inputmask.keyCode.DELETE, pos), 
            WriteBuffer (entrée, GetBuffer (), getMaskSet (). p, e, undoValue! == GetBuffer (). join ( "")), 
            input.inputmask._valueGet () === getBufferTemplate (). join ("") && $ input.trigger ("effacé"), 
            opts.showTooltip && (input.title = opts.tooltip || getMaskSet (). mask);
        }
        fonction blurEvent (e) {
            var $ input = $ (this), input = this;
            if (input.inputmask) {
                var nptValue = input.inputmask._valueGet (), buffer = getBuffer (). slice ();
                undoValue! == buffer.join ("") && setTimeout (function () {
                    $ input.trigger ("change"), undoValue = buffer.join ("");
                }, 0), ""! == nptValue && (opts.clearMaskOnLostFocus && (getLastValidPosition () === -1 && nptValue === getBufferTemplate (). Join ("")? Buffer = []: clearOptionalTail (buffer) ), 
                isComplete (buffer) ===! 1 && (setTimeout (function () {
                    $ input.trigger ("incomplet");
                }, 0), opts.clearIncomplete && (resetMaskSet (), buffer = opts.clearMaskOnLostFocus? []: GetBufferTemplate (). Slice ()), 
                writeBuffer (entrée, tampon, vide 0, e));
            }
        }
        function mouseenterEvent (e) {
            var input = this;
            mouseEnter =! 0, document.activeElement! == input && opts.showMaskOnHover && input.inputmask._valueGet ()! == getBuffer (). join ("") && writeBuffer (input, getBuffer ());
        }
        function submitEvent (e) {
            undoValue! == getBuffer (). join ("") && $ el.trigger ("change"), opts.clearMaskOnLostFocus && getLastValidPosition () === -1 && el.inputmask._valueGet && el.inputmask._valueGet () === getBufferTemplate (). join ("") && el.inputmask._valueSet (""), 
            opts.removeMaskOnSubmit && (el.inputmask._valueSet (el.inputmask.unmaskedvalue (),! 0), 
            setTimeout (function () {
                writeBuffer (el, getBuffer ());
            }, 0));
        }
        fonction resetEvent (e) {
            setTimeout (function () {
                $ el.trigger ("setvalue");
            }, 0);
        }
        fonction initializeColorMask (entrée) {
            fonction findCaretPos (clientx) {
                var caretPos, e = document.createElement ("span");
                pour (style var dans computedStyle) isNaN (style) && style.indexOf ( "Police") == -1 && (e.style [style] = computedStyle [style])!;
                e.style.textTransform = computedStyle.textTransform, e.style.letterSpacing = computedStyle.letterSpacing, 
                e.style.position = "absolu", e.style.height = "auto", e.style.width = "auto", 
                e.style.visibility = "caché", e.style.whiteSpace = "nowrap", document.body.appendChild (e);
                var itl, inputText = input.inputmask._valueGet (), previousWidth = 0;
                pour (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos ++) {
                    if (e.innerHTML + = inputText.charAt (caretPos) || "_", e.offsetWidth> = clientx) {
                        var offset1 = clientx - previousWidth, offset2 = e.offsetWidth - clientx;
                        e.innerHTML = inputText.charAt (caretPos), offset1 - = e.offsetWidth / 3, caretPos = offset1 <offset2? CaretPos - 1: CaretPos;
                        Pause;
                    }
                    previousWidth = e.offsetWidth;
                }
                renvoyer document.body.removeChild (e), caretPos;
            }
            fonction position () {
                colorMask.style.position = "absolute", colorMask.style.top = offset.top + "px", 
                colorMask.style.left = offset.left + "px", colorMask.style.width = parseInt (input.offsetWidth) - parseInt (computedStyle.paddingLeft) - parseInt (computedStyle.paddingRight) - parseInt (computedStyle.borderLog) computedStyle.borderRightWidth) + "px", 
                colorMask.style.height = parseInt (input.offsetHeight) - parseInt (computedStyle.paddingTop) - parseInt (computedStyle.paddingBottom) - parseInt (computedStyle.borderTopWidth) - parseInt (computedStyle.borderbough) 
                colorMask.style.lineHeight = colorMask.style.height, colorMask.style.zIndex = isNaN (computedStyle.zIndex)? -1: computedStyle.zIndex - 1,
                colorMask.style.webkitAppearance = "textfield", colorMask.style.mozAppearance = "textfield", 
                colorMask.style.Appearance = "textfield";
            }
            var offset = $ (entrée) .position (), computedStyle = (input.ownerDocument.defaultView || fenêtre) .getComputedStyle (entrée, null);
            input.parentNode;
            colorMask = document.createElement ("div"), document.body.appendChild (colorMask);
            for (style var dans computedStyle) isNaN (style) && "cssText"! == style && style.indexOf ("webkit") == -1 && (colorMask.style [style] = computedStyle [style]);
            input.style.backgroundColor = "transparent", input.style.color = "transparent", 
            input.style.webkitAppearance = "caret", input.style.mozAppearance = "caret", input.style.Appearance = "caret", 
            position (), $ (fenêtre) .on ("redimensionner", fonction (e) {
                offset = $ (entrée) .position (), computedStyle = (input.ownerDocument.defaultView || fenêtre) .getComputedStyle (entrée, null), 
                position();
            }), $ (entrée) .on ("clic", fonction (e) {
                return caret (input, findCaretPos (e.clientX)), clickEvent.call (this, [e]);
            });
        }
        function renderColorMask (input, buffer, caretPos) {
            function handleStatic () {
                statique || null! == test.fn && void 0! == testPos.input? static && null! == test.fn && void 0! == testPos.input && (static =! 1,
                maskTemplate + = "</ span>"): (static =! 0, maskTemplate + = "<span class = 'im-static' '>");
            }
            if (void 0! == colorMask) {
                tampon = tampon || getBuffer (), void 0 === caretPos? caretPos = caret (entrée): void 0 === caretPos.begin && (caretPos = {
                    commencer: caretPos,
                    fin: caretPos
                });
                var maskTemplate = "", static =! 1;
                if (""! = buffer) {
                    var ndxIntlzr, test, testPos, pos = 0, lvp = getLastValidPosition ();
                    do pos === caretPos.begin && document.activeElement === input && (maskTemplate + = "<span class = 'im-caret' style = 'border-right-width: 1px; border-right-style: solide; '> </ span> "), 
                    getMaskSet (). validPositions [pos]? (testPos = getMaskSet (). validPositions [pos],
                    test = testPos.match, ndxIntlzr = testPos.locator.slice (), handleStatic (), maskTemplate + = testPos.input): (testPos = getTestTemplate (pos, ndxIntlzr, pos - 1), 
                    test = testPos.match, ndxIntlzr = testPos.locator.slice (), (opts.jitMasking ===! 1 || pos <lvp || Number.isFinite (opts.jitMasking) && opts.jitMasking> pos) && (handleStatique) (), 
                    maskTemplate + = getPlaceholder (pos, test))), pos ++; while ((void 0 === maxLength || pos <maxLength) && (null! == test.fn || ""! == test.def) || lvp> pos);
                }
                colorMask.innerHTML = maskTemplate;
            }
        }
        masque de fonction (elem) {
            fonction isElementTypeSupported (input, opts) {
                var elementType = input.getAttribute ("type"), isSupported = "INPUT" === input.tagName && $ .inArray (elementType, opts.supportsInputType)! == -1 || input.isContentEditable || "TEXTAREA" === input.tagName;
                if (! isSupported && "INPUT" === input.tagName) {
                    var el = document.createElement ("input");
                    el.setAttribute ("type", elementType), isSupported = "text" === el.type, el = null;
                }
                return isSupported;
            }
            if (isElementTypeSupported (elem, opts) && (el = elem, $ el = $ (el), opts.showTooltip && (el.title = opts.tooltip || getMaskSet (). mask), 
            ("rtl" === el.dir || opts.rightAlign) && (el.style.textAlign = "right"), ("rtl" === el.dir || opts.numericInput) && (el.dir = "ltr", 
            el.removeAttribute ("dir"), el.inputmask.isRTL =! 0, isRTL =! 0), opts.colorMask ===! 0 && initializeColorMask (el), 
            android && (el.hasOwnProperty ("inputmode") && (el.inputmode = opts.inputmode, el.setAttribute ("inputmode", opts.inputmode)), 
            "rtfm" === opts.androidHack && (opts.colorMask! ==! 0 && initializeColorMask (el), 
            el.type = "password")), EventRuler.off (el), patchValueProperty (el), EventRuler.on (el, "submit", submitEvent), 
            EventRuler.on (el, "reset", resetEvent), EventRuler.on (el, "mouseenter", mouseenterEvent), 
            EventRuler.on (el, "blur", blurEvent), EventRuler.on (el, "focus", focusEvent), EventRuler.on (el, "mouseleave", mouseleaveEvent), 
            opts.colorMask! ==! 0 && EventRuler.on (el, "clic", clickEvent), EventRuler.on (el, "dblclick", dblclickEvent), 
            EventRuler.on (el, "paste", pasteEvent), EventRuler.on (el, "dragdrop", pasteEvent), 
            EventRuler.on (el, "drop", pasteEvent), EventRuler.on (el, "cut", cutEvent), EventRuler.on (el, "complete", opts.oncomplete), 
            EventRuler.on (el, "incomplet", opts.onincomplete), EventRuler.on (el, "effacé", opts.oncleared), 
            opts.inputEventOnly! ==! 0 && (EventRuler.on (el, "keydown", keydownEvent), EventRuler.on (el, "keypress", keypressEvent)), 
            EventRuler.on (el, "compositionstart", $ .noop), EventRuler.on (el, "compositionupdate", $ .noop), 
            EventRuler.on (el, "compositionend", $ .noop), EventRuler.on (el, "keyup", $ .noop), 
            EventRuler.on (el, "entrée", inputFallBackEvent), EventRuler.on (el, "setvalue", setValueEvent), 
            getBufferTemplate (), ""! == el.inputmask._valueGet () || opts.clearMaskOnLostFocus ===! 1 || document.activeElement === el)) {
                var initialValue = $ .isFunction (opts.onBeforeMask)? opts.onBeforeMask (el.inputmask._valueGet (), opts) || el.inputmask._valueGet (): el.inputmask._valueGet ();
                checkVal (el,! 0,! 1, initialValue.split (""));
                var buffer = getBuffer (). slice ();
                undoValue = buffer.join (""), isComplete (tampon) ===! 1 && opts.clearIncomplete && resetMaskSet (), 
                opts.clearMaskOnLostFocus && document.activeElement! == el && (getLastValidPosition () === -1? buffer = []: clearOptionalTail (tampon)), 
                writeBuffer (el, tampon), document.activeElement === el && caret (el, seekNext (getLastValidPosition ()));
            }
        }
        var undoValue, el, $ el, maxLength, colorMask, valueBuffer, isRTL =! 1, skipKeyPressEvent =! 1, skipInputEvent =! 1, ignorable =! 1, mouseEnter =! 1, EventRuler = {
            on: function (input, eventName, eventHandler) {
                var ev = fonction (e) {
                    if (void 0 === this.inputmask && "FORM"! == this.nodeName) {
                        var imOpts = $ .data (this, "_inputmask_opts");
                        imOpts? new Inputmask (imOpts) .mask (this): EventRuler.off (this);
                    } autre {
                        if ("setvalue" === e.type ||! (this.disabled || this.readOnly &&!! "" keydown "=== e.type && e.ctrlKey && 67 === e.keyCode || opte .tabThrough ===! 1 && e.keyCode === Inputmask.keyCode.TAB))) {
                            commutateur (type e) {
                              cas "entrée":
                                if (skipInputEvent ===! 0) renvoie skipInputEvent =! 1, e.preventDefault ();
                                Pause;

                              cas "keydown":
                                skipKeyPressEvent =! 1, skipInputEvent =! 1;
                                Pause;

                              cas "touche":
                                if (skipKeyPressEvent ===! 0) renvoie e.preventDefault ();
                                skipKeyPressEvent =! 0;
                                Pause;

                              cas "clic":
                                si (iemobile || iphone) {
                                    var que = ceci, args = arguments;
                                    retourne setTimeout (function () {
                                        eventHandler.apply (that, args);
                                    }, 0),! 1;
                                }
                            }
                            var returnVal = eventHandler.apply (this, arguments);
                            return returnVal ===! 1 && (e.preventDefault (), e.stopPropagation ()), returnVal;
                        }
                        e.preventDefault ();
                    }
                };
                input.inputmask.events [eventName] = input.inputmask.events [eventName] || [], input.inputmask.events [NomEvent] .push (ev),
                $ .inArray (eventName, ["submit", "reset"])! == -1? null! = input.form && $ (input.form) .on (eventName, ev): $ (input) .on (eventName, ev);
            },
            off: fonction (entrée, événement) {
                if (input.inputmask && input.inputmask.events) {
                    var événements;
                    un événement ? (events = [], events [event] = input.inputmask.events [event]): events = input.inputmask.events,
                    $ .each (événements, fonction (eventName, evArr) {
                        pour (; evArr.length> 0;) {
                            var ev = evArr.pop ();
                            $ .inArray (eventName, ["submit", "reset"])! == -1? null! = input.form && $ (input.form) .off (eventName, ev): $ (input) .off (eventName, ev);
                        }
                        delete input.inputmask.events [nomEvénement];
                    });
                }
            }
        };
        si (void 0! == actionObj) commute (actionObj.action) {
          cas "isComplete":
            return el = actionObj.el, isComplete (getBuffer ());

          case "unmaskedvalue":
            return el = actionObj.el, void 0! == el && void 0! == el.inputmask? (maskset = el.inputmask.maskset,
            opts = el.inputmask.opts, isRTL = el.inputmask.isRTL): (valueBuffer = actionObj.value, 
            opts.numericInput && (isRTL =! 0), valueBuffer = ($ .isFunction (opts.onBeforeMask)? opts.onBeforeMask (valueBuffer, opts) || valueBuffer: valueBuffer (""), 
            checkVal (void 0,! 1,! 1, isRTL? valueBuffer.reverse (): valueBuffer), $ .isFunction (opts.onBeforeWrite) && opts.onBeforeWrite (void 0, getBuffer (), 0, opts)), 
            démasqué valeur (el);

          cas "masque":
            el = actionObj.el, maskset = el.inputmask.maskset, opts = el.inputmask.opts, isRTL = el.inputmask.isRTL, 
            masque (el);
            Pause;

          cas "format":
            return opts.numericInput && (isRTL =! 0), valueBuffer = ($ .isFunction (opts.onBeforeMask)? opts.onBeforeMask (actionObj.value, opts) || actionObj.value: actionObj.value ("")) , 
            checkVal (void 0,! 1,! 1, isRTL? valueBuffer.reverse (): valueBuffer), $ .isFunction (opts.onBeforeWrite) && opts.onBeforeWrite (void 0, getBuffer (), 0, opts), 
            actionObj.metadata? {
                valeur: isRTL? getBuffer (). slice (). reverse (). join (""): getBuffer (). join (""),
                métadonnées: maskScope ({
                    action: "getmetadata"
                }, maskset, opts)
            }: isRTL? getBuffer (). slice (). reverse (). join (""): getBuffer (). join ("");

          cas "isValid":
            opts.numericInput && (isRTL =! 0), actionObj.value? (valueBuffer = actionObj.value.split (""),
            checkVal (void 0,! 1,! 0, isRTL? valueBuffer.reverse (): valueBuffer)): actionObj.value = getBuffer (). join ("");
            pour (tampon var = GetBuffer (), rl = determineLastRequiredPosition (), LMIB = buffer.Length - 1;! LMIB> rl && isMask (LMIB); lmib--);
            retourner buffer.splice (rl, LMIB + 1 - RL), isComplete (tampon) && actionObj.value === GetBuffer () join ( "");.

          cas "getemptymask":
            retournez getBufferTemplate (). join ("");

          cas "enlever":
            el = actionObj.el, $ el = $ (el), maskset = el.inputmask.maskset, opts = el.inputmask.opts, 
            el.inputmask._valueSet (unmaskedvalue (el)), EventRuler.off (el);
            var valueProperty;
            Object.getOwnPropertyDescriptor && Object.getPrototypeOf? (valueProperty = Object.getOwnPropertyDescriptor (Object.getPrototypeOf (el), "valeur"),
            valueProperty && el.inputmask .__ valueGet && Object.defineProperty (el, "valeur", {
                get: el.inputmask .__ valueGet,
                set: el.inputmask .__ valueSet,
                configurable:! 0
            })): document .__ lookupGetter__ && el .__ lookupGetter __ ("value") && el.inputmask .__ valueGet && (el .__ defineGetter __ ("valeur", el.inputmask .__ valueGet), 
            el .__ defineSetter __ ("valeur", el.inputmask .__ valueSet)), el.inputmask = void 0;
            Pause;

          cas "getmetadata":
            if ($ .isArray (maskset.metadata)) {
                var maskTarget = getMaskTemplate (! 0, 0,! 1) .join ("");
                retourne $ .each (maskset.metadata, fonction (ndx, mtdt) {
                    if (mtdt.mask === maskTarget) renvoie maskTarget = mtdt,! 1;
                }), maskTarget;
            }
            return maskset.metadata;
        }
    }
    var ua = navigator.userAgent, mobile = /mobile/i.test(ua), iemobile = /iemobile/i.test(ua), iphone = /iphone/i.test(ua) &&! iemobile, android = / android /i.test(ua) &&! iemobile;
    return Inputmask.prototype = {
        valeurs par défaut: {
            espace réservé: "_",
            marqueur facultatif: {
                début: "[",
                fin: "]"
            },
            marqueur de quantification: {
                début: "{",
                fin: "}"
            },
            marqueur de groupe: {
                début: "(",
                fin: ")"
            },
            alternatormarker: "|",
            escapeChar: "\\",
            masque: nul,
            onComplete: .noop $,
            onincomplete: $ .noop,
            oncleared: .noop $,
            répéter: 0,
            gourmand:! 0,
            autoUnmask:! 1,
            removeMaskOnSubmit:! 1,
            clearMaskOnLostFocus:! 0,
            insertMode:! 0,
            clearIncomplete:! 1,
            alias: {},
            alias: null,
            onKeyDown: $ .noop,
            onBeforeMask: null,
            onBeforePaste: function (pastedValue, opts) {
                renvoyer $ .isFunction (opts.onBeforeMask)? opts.onBeforeMask (colledValue, opts): colledValue;
            },
            onBeforeWrite: null,
            onUnMask: null,
            showMaskOnFocus:! 0,
            showMaskOnHover:! 0,
            onKeyValidation: $ .noop,
            skipOptionalPartCharacter: "",
            showTooltip:! 1,
            info-bulle: vide 0,
            entrée numérique:! 1,
            rightAlign:! 1,
            undoOnEscape:! 0,
            radixPoint: "",
            radixPointDefinitionSymbol: void 0,
            groupSeparator: "",
            keepStatic: null,
            positionCaretOnTab:! 0,
            tabThrough:! 1,
            supportsInputType: ["text", "tel", "mot de passe"],
            définitions: {
                "9": {
                    validateur: "[0-9]",
                    cardinalité: 1,
                    definitionSymbol: "*"
                },
                une: {
                    validateur: "[A-Za-z \ u0410- \ u044f \ u0401 \ u0451 \ xc0- \ xff \ xb5]",
                    cardinalité: 1,
                    definitionSymbol: "*"
                },
                "*": {
                    validateur: "[0-9A-Za-z \ u0410- \ u044f \ u0401 \ u0451 \ xc0- \ xff \ xb5]",
                    cardinalité: 1
                }
            },
            ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119 , 120, 121, 122, 123],
            isComplete: null,
            canClearPosition: $ .noop,
            postValidation: null,
            staticDefinitionSymbol: void 0,
            jitMasking:! 1,
            nullable:! 0,
            inputEventOnly:! 1,
            noValuePatching:! 1,
            positionCaretOnClick: "lvp",
            boîtier: nul,
            inputmode: "verbatim",
            ColorMask:! 1,
            androidHack:! 1
        },
        masksCache: {},
        masque: fonction (elems) {
            fonction importAttributeOptions (npt, opts, userOptions, dataAttribute) {
                fonction importOption (option, optionData) {
                    optionData = void 0! == optionData? optionData: npt.getAttribute (dataAttribute + "-" + option),
                    null! == optionData && ("chaîne" == typeof optionData && (0 === option.indexOf ("on")? optionData = window [optionData]: "false" === optionData? optionData =! 1: " true "=== optionData && (optionData =! 0)), 
                    userOptions [option] = optionData);
                }
                var option, dataoptions, optionData, p, attrOptions = npt.getAttribute (dataAttribute);
                if (attrOptions && ""! == attrOptions && (attrOptions = attrOptions.replace (new RegExp ("'", "g"), ""), 
                dataoptions = JSON.parse ("{" + attrOptions + "}")), dataoptions) {
                    optionData = void 0;
                    for (p dans dataoptions) if ("alias" === p.toLowerCase ()) {
                        optionData = dataoptions [p];
                        Pause;
                    }
                }
                importOption ("alias", optionData), userOptions.alias && that.resolveAlias ​​(userOptions.alias, userOptions, opts);
                pour (option dans opts) {
                    if (options de données) {
                        optionData = void 0;
                        for (p dans dataoptions) if (p.toLowerCase () === option.toLowerCase ()) {
                            optionData = dataoptions [p];
                            Pause;
                        }
                    }
                    importOption (option, optionData);
                }
                return $ .extend (! 0, opts, options utilisateur), opte;
            }
            var que = ceci;
            renvoie "chaîne" == typeof elems && (elems = document.getElementById (elems) || document.querySelectorAll (elems)), 
            elems = elems.nodeName? [elems]: elems, $ .each (elems, function (ndx, el) {
                var scopedOpts = $ .extend (! 0, {}, that.opts);
                importAttributeOptions (el, scopedOpts, $ .extend (! 0, {}, that.userOptions), that.dataAttribute);
                var maskset = generateMaskSet (scopedOpts, that.noMasksCache);
                void 0! == maskset && (void 0! == el.inputmask && el.inputmask.remove (), el.inputmask = new Inputmask (), 
                el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = $ .extend (! 0, {}, that.userOptions), 
                el.inputmask.el = el, el.inputmask.maskset = ensemble de masques, el.inputmask.isRTL =! 1, $ .data (el, "_inputmask_opts", scopedOpts), 
                maskScope ({
                    action: "masque",
                    el: el
                }));
            }), elems && elems [0]? elems [0] .inputmask || ça ça;
        },
        option: fonction (options, noremask) {
            retourne "string" == options typeof? this.opts [options]: "objet" == options de typeof? ($ .extend (this.userOptions, options),
            this.el && noremask! ==! 0 && this.mask (this.el), this): void 0;
        },
        unmaskedvalue: function (value) {
            return maskScope ({
                action: "unmaskedvalue",
                el: this.el,
                valeur: valeur
            }, this.el && this.el.inputmask? this.el.inputmask.maskset: generateMaskSet (this.opts, this.noMasksCache), this.opts);
        },
        remove: function () {
            if (this.el) renvoie maskScope ({
                action: "enlever",
                el: this.el
            }), this.el.inputmask = vide 0, this.el;
        },
        getemptymask: function () {
            return maskScope ({
                action: "getemptymask"
            }, this.maskset || generateMaskSet (this.opts, this.noMasksCache), this.opts);
        },
        hasMaskedValue: function () {
            return! this.opts.autoUnmask;
        },
        isComplete: function () {
            return maskScope ({
                action: "isComplete",
                el: this.el
            }, this.maskset || generateMaskSet (this.opts, this.noMasksCache), this.opts);
        },
        getmetadata: function () {
            return maskScope ({
                action: "getmetadata"
            }, this.maskset || generateMaskSet (this.opts, this.noMasksCache), this.opts);
        },
        isValid: fonction (valeur) {
            return maskScope ({
                action: "isValid",
                valeur: valeur
            }, this.maskset || generateMaskSet (this.opts, this.noMasksCache), this.opts);
        },
        format: fonction (valeur, métadonnées) {
            return maskScope ({
                action: "format",
                valeur: valeur,
                métadonnées: métadonnées
            }, this.maskset || generateMaskSet (this.opts, this.noMasksCache), this.opts);
        },
        analyseMask: fonction (masque, opte) {
            function MaskToken (isGroup, isOptional, isQuantifier, isAlternator) {
                this.matches = [], this.isGroup = isGroup || ! 1, this.isOptional = isOptional || !1,
                this.isQuantifier = isQuantifier || ! 1, this.isAlternator = isAlternator || !1,
                this.quantifier = {
                    min: 1,
                    max: 1
                };
            }
            fonction insertTestDefinition (mtoken, element, position) {
                var maskdef = opts.definitions [element];
                position = void 0! == position? position: mtoken.matches.length;
                var prevMatch = mtoken.matches [position - 1];
                si (masquedef &&! échappé) {
                    maskdef.placeholder = $ .isFunction (maskdef.placeholder)? maskdef.placeholder (optant): maskdef.placeholder;
                    for (var prévalidators = maskdef.prevalidator, prévalidatorsL = prévalidators? prévalidators.length: 0, i = 1; i <maskdef.cardinality; i ++) {
                        var prévalidateur = prévalidatorL> = i? prévalidateurs [i - 1]: [], validateur = prévalidateur.validateur, cardinalité = prévalidateur.cardinalité;
                        mtoken.matches.splice (position ++, 0, {
                            fn: validateur? "chaîne" == typeof validator? new RegExp (validator): nouvelle fonction () {
                                this.test = validateur;
                            } (): nouvelle RegExp ("."),
                            cardinalité: cardinalité? cardinalité: 1,
                            optionnel: mtoken.isOptional,
                            newBlockMarker: void 0 === prevMatch || prevMatch.def! == (élément maskdef.definitionSymbol ||),
                            boîtier: maskdef.casing,
                            def: maskdef.definitionSymbol || élément,
                            placeholder: maskdef.placeholder,
                            nativeDef: element
                        }), prevMatch = mtoken.matches [position - 1];
                    }
                    mtoken.matches.splice (position ++, 0, {
                        fn: maskdef.validator? "string" == typeof maskdef.validator? new RegExp (maskdef.validator): nouvelle fonction () {
                            this.test = maskdef.validator;
                        } (): nouvelle RegExp ("."),
                        cardinalité: maskdef.cardinality,
                        optionnel: mtoken.isOptional,
                        newBlockMarker: void 0 === prevMatch || prevMatch.def! == (élément maskdef.definitionSymbol ||),
                        boîtier: maskdef.casing,
                        def: maskdef.definitionSymbol || élément,
                        placeholder: maskdef.placeholder,
                        nativeDef: element
                    });
                } else mtoken.matches.splice (position ++, 0, {
                    fn: null,
                    cardinalité: 0,
                    optionnel: mtoken.isOptional,
                    newBlockMarker: void 0 === prevMatch || prevMatch.def! == élément,
                    boîtier: nul,
                    def: opts.staticDefinitionSymbol || élément,
                    espace réservé: vide 0! == opts.staticDefinitionSymbol? élément: vide 0,
                    nativeDef: element
                }), échappé =! 1;
            }
            function verifyGroupMarker (lastMatch, isOpenGroup) {
                lastMatch && lastMatch.isGroup && (lastMatch.isGroup =! 1, insertTestDefinition (lastMatch, opts.groupmarker.start, 0), 
                isOpenGroup! ==! 0 && insertTestDefinition (lastMatch, opts.groupmarker.end));
            }
            function maskCurrentToken (m, currentToken, lastMatch, extraCondition) {
                currentToken.matches.length> 0 && (void 0 === extraCondition || extraCondition) && (lastMatch = currentToken.matches [currentToken.matches.length - 1], 
                verifyGroupMarker (lastMatch)), insertTestDefinition (currentToken, m);
            }
            fonction defaultCase () {
                if (openenings.length> 0) {
                    if (currentOpeningToken = openenings [openenings.length - 1], maskCurrentToken (m, currentOpeningToken, lastMatch,! currentOpeningToken.isAlternator), 
                    currentOpeningToken.isAlternator) {
                        alternateur = openenings.pop ();
                        pour (var mndx = 0; mndx <alternator.matches.length; mndx ++) alternator.matches [mndx] .isGroup =! 1;
                        openenings.length> 0? (currentOpeningToken = openenings [openenings.length - 1],
                        currentOpeningToken.matches.push (alternateur)): currentToken.matches.push (alternateur);
                    }
                } else maskCurrentToken (m, currentToken, lastMatch);
            }
            fonction reverseTokens (maskToken) {
                fonction reverseStatic (st) {
                    retourne st === opts.optionalmarker.start? st = opts.optionalmarker.end: st === opts.optionalmarker.end? st = opts.optionalmarker.start: st === opts.groupmarker.start? st = opts.groupmarker.end: st === opts.groupmarker.end && (st = opts.groupmarker.start),
                    st;
                }
                maskToken.matches = maskToken.matches.reverse ();
                pour (var match dans maskToken.matches) {
                    var intMatch = parseInt (match);
                    if (maskToken.matches [match] .isQuantifier && maskToken.matches [intMatch + 1] && maskToken.matches [intMatch + 1] .isGroup) {
                        var qt = maskToken.matches [match];
                        maskToken.matches.splice (match, 1), maskToken.matches.splice (intMatch + 1, 0, qt);
                    }
                    void 0! == maskToken.matches [match] .matches? maskToken.matches [match] = reverseTokens (maskToken.matches [match]): maskToken.matches [match] = reverseStatic (maskToken.matches [match]);
                }
                return maskToken;
            }
            pour (var match, m, openingToken, currentOpeningToken, alternateur, lastMatch, groupToken, tokenizer = / (?: [? * +] | \ {[0-9 \ + \ *] + (?:,, [0-9 \ + \ *] *)? \}) | [^.? * + ^ $ {[] () | \\] + | ./g, échappé =! 1, currentToken = new MaskToken (), openenings = [] , maskTokens = []; match = tokenizer.exec (masque);) if (m = match [0], 
            échappé) defaultCase (); else switch (m.charAt (0)) {
              cas opts.escapeChar:
                échappé =! 0;
                Pause;

              case opts.optionalmarker.end:
              case opts.groupmarker.end:
                if (openingToken = openenings.pop (), vide 0! == openingToken) if (openenings.length> 0) {
                    if (currentOpeningToken = openenings [openenings.length - 1], currentOpeningToken.matches.push (openingToken), 
                    currentOpeningToken.isAlternator) {
                        alternateur = openenings.pop ();
                        pour (var mndx = 0; mndx <alternator.matches.length; mndx ++) alternator.matches [mndx] .isGroup =! 1;
                        openenings.length> 0? (currentOpeningToken = openenings [openenings.length - 1],
                        currentOpeningToken.matches.push (alternateur)): currentToken.matches.push (alternateur);
                    }
                } else currentToken.matches.push (openingToken); else defaultCase ();
                Pause;

              case opts.optionalmarker.start:
                verifyGroupMarker (currentToken.matches [currentToken.matches.length - 1]), openenings.push (nouveau MaskToken ((! 1), (! 0)));
                Pause;

              case opts.groupmarker.start:
                verifyGroupMarker (currentToken.matches [currentToken.matches.length - 1]), openenings.push (new MaskToken ((! 0)));
                Pause;

              case opts.quantifiermarker.start:
                quantificateur var = new MaskToken ((! 1), (! 1), (! 0));
                m = m.replace (/ [{}] / g, "");
                var mq = m.split (","), mq0 = isNaN (mq [0])? mq [0]: parseInt (mq [0]), mq1 = 1 === mq.length? mq0: isNaN (mq [1])? mq [1]: analyseInt (mq [1]);
                si ("*"! == mq1 && "+"! == mq1 || (mq0 = "*" === mq1? 0: 1), quantifier.quantifier = {
                    min: mq0,
                    max: mq1
                }, openenings.length> 0) {
                    var correspond = openenings [openenings.length - 1] .matches;
                    match = matches.pop (), match.isGroup || (groupToken = new MaskToken ((! 0)), groupToken.matches.push (match),
                    match = groupToken), matches.push (match), matches.push (quantifier);
                } else match = currentToken.matches.pop (), match.isGroup || (groupToken = new MaskToken ((! 0)),
                groupToken.matches.push (match), match = groupToken), currentToken.matches.push (match), 
                currentToken.matches.push (quantificateur);
                Pause;

              cas opts.alternatormarker:
                openenings.length> 0? (currentOpeningToken = openenings [openenings.length - 1],
                lastMatch = currentOpeningToken.matches.pop ()): lastMatch = currentToken.matches.pop (), 
                lastMatch.isAlternator? openenings.push (lastMatch): (alternateur = nouveau MaskToken ((! 1), (! 1), (! 1), (! 0), (! 0)),
                alternator.matches.push (lastMatch), openenings.push (alternateur));
                Pause;

              défaut:
                defaultCase ();
            }
            pour (; openenings.length> 0;) openingToken = openenings.pop (), verifyGroupMarker (openingToken,! 0), 
            currentToken.matches.push (openingToken);
            return currentToken.matches.length> 0 && (lastMatch = currentToken.matches [currentToken.matches.length - 1], 
            verifyGroupMarker (lastMatch), maskTokens.push (currentToken)), opts.numericInput && reverseTokens (maskTokens [0]), 
            maskTokens;
        },
        resolAlias: function (aliasStr, options, opts) {
            var aliasDefinition = opts.aliases [aliasStr];
            renvoyer aliasDefinition? (aliasDefinition.alias && this.resolveAlias ​​(aliasDefinition.alias, vide 0, opts),
            $ .extend (! 0, opts, aliasDefinition), $ .extend (! 0, opts, options),! 0): (null === opts.mask && (opts.mask = aliasStr), 
            !1);
        }
    }, Inputmask.extendDefaults = fonction (options) {
        $ .extend (! 0, Inputmask.prototype.defaults, options);
    }, Inputmask.extendDefinitions = function (définition) {
        $ .extend (! 0, Inputmask.prototype.defaults.definitions, définition);
    }, Inputmask.extendAliases = function (alias) {
        $ .extend (! 0, Inputmask.prototype.defaults.aliases, alias);
    }, Inputmask.format = function (valeur, options, métadonnées) {
        return Inputmask (options) .format (valeur, métadonnées);
    }, Inputmask.unmask = function (valeur, options) {
        return Inputmask (options) .unmaskedvalue (valeur);
    }, Inputmask.isValid = fonction (valeur, options) {
        return Inputmask (options) .isValid (valeur);
    }, Inputmask.remove = function (elems) {
        $ .each (elems, function (ndx, el) {
            el.inputmask && el.inputmask.remove ();
        });
    }, Inputmask.escapeRegex = function (str) {
        var specials = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "} "," \\ "," $ "," ^ "];
        return str.replace (new RegExp ("(\\" + specials.join ("| \\") + ")", "gim"), "\\ $ 1");
    }, Inputmask.keyCode = {
        ALT: 18,
        RETOUR ARRIÈRE: 8
        BACKSPACE_SAFARI: 127,
        CAPS_LOCK: 20,
        COMMA: 188,
        COMMAND: 91,
        COMMAND_LEFT: 91,
        COMMAND_RIGHT: 93,
        CONTRÔLE: 17
        SUPPRIMER: 46,
        DOWN: 40,
        FIN: 35,
        ENTER: 13,
        ÉVASION: 27
        ACCUEIL: 36
        INSÉRER: 45,
        GAUCHE: 37
        MENU: 93,
        NUMPAD_ADD: 107,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        NUMPAD_ENTER: 108,
        NUMPAD_MULTITIY: 106,
        NUMPAD_SUBTRACT: 109,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PÉRIODE: 190
        DROITE: 39
        MAJ: 16,
        ESPACE: 32
        TAB: 9
        UP: 38
        FENÊTRES: 91,
        X: 88
    }, window.Inputmask = Masque d'entrée, Masque d'entrée;
} (jQuery), fonction ($, masque de saisie) {
    return void 0 === $ .fn.inputmask && ($ .fn.inputmask = fonction (fn, options) {
        var nptmask, input = this [0];
        if (void 0 === options && (options = {}), "chaîne" == typeof fn) commutateur (fn) {
          case "unmaskedvalue":
            retourne input && input.inputmask? input.inputmask.unmaskedvalue (): $ (input) .val ();

          cas "enlever":
            retourne this.each (function () {
                this.inputmask && this.inputmask.remove ();
            });

          cas "getemptymask":
            retourne input && input.inputmask? input.inputmask.getemptymask (): "";

          cas "hasMaskedValue":
            return! (! input ||! input.inputmask) && input.inputmask.hasMaskedValue ();

          cas "isComplete":
            retour! entrée || ! input.inputmask || input.inputmask.isComplete ();

          cas "getmetadata":
            retourne input && input.inputmask? input.inputmask.getmetadata (): void 0;

          case "setvalue":
            $ (input) .val (options), input && void 0 === input.inputmask && $ (input) .triggerHandler ("setvalue");
            Pause;

          cas "option":
            if ("string"! = typeof options) renvoie this.each (function () {
                if (void 0! == this.inputmask) renvoie this.inputmask.option (options);
            });
            if (input && void 0! == input.inputmask) renvoie input.inputmask.option (options);
            Pause;

          défaut:
            return options.alias = fn, nptmask = new Le masque de saisie (options), this.each (function () {
                nptmask.mask (this);
            });
        } autre {
            if ("object" == typeof fn) renvoie nptmask = new Inputmask (fn), void 0 === fn.mask && void 0 === fn.alias? this.each (function () {
                renvoie vide 0! == this.inputmask? this.inputmask.option (fn): void nptmask.mask (this);
            }): this.each (function () {
                nptmask.mask (this);
            });
            if (void 0 === fn) renvoie this.each (function () {
                nptmask = new Inputmask (options), nptmask.mask (this);
            });
        }
    }), $ .fn.inputmask;
} (jQuery, Inputmask), fonction ($, Inputmask) {} (jQuery, Inputmask), fonction ($, Inputmask) {
    fonction isLeapYear (year) {
        retour isNaN (année) || 29 === nouvelle date (année, 2, 0) .getDate ();
    }
    retourne Inputmask.extendAliases ({
        "jj / mm / aaaa": {
            masque: "1/2 / y",
            espace réservé: "jj / mm / aaaa",
            regex: {
                val1pre: new RegExp ("[0-3]"),
                val1: new RegExp ("0 [1-9] | [12] [0-9] | 3 [01]"),
                val2pre: fonction (séparateur) {
                    var escapedSeparator = Inputmask.escapeRegex.call (this, separator);
                    return new RegExp ("((0 [1-9] | [12] [0-9] | 3 [01])" + escapedSeparator + "[01])");
                },
                val2: fonction (séparateur) {
                    var escapedSeparator = Inputmask.escapeRegex.call (this, separator);
                    retourne une nouvelle RegExp ("(((0 [1-9] | [12] [0-9])" + escapedSeparator + "(0 [1-9] | 1 [012])) | (30" + escapedSeparator + " (0 [13-9] | 1 [012])) | (31 "+ escapedSeparator +" (0 [13578] | 1 [02])) ");
                }
            },
            jour de lundi: "29/02 /",
            séparateur: "/",
            année: {
                minyear: 1900,
                maxyear: 2099
            },
            isInYearRange: function (chrs, minyear, maxyear) {
                if (isNaN (chrs)) renvoie! 1;
                var entryyear = parseInt (chrs.concat (minyear.toString (). slice (chrs.length))), entryyear2 = parseInt (chrs.concat (maxyear.toString (). slice (chrs.length)));
                return! isNaN (année entrée) && (min année <= entrée année && entrée année <= max année) || ! isNaN (entryyear2) && (minyear <= entryyear2 && entryyear2 <= maxyear);
            },
            Determine Baseyear: fonction (minyear, maxyear, indice) {
                var currentyear = new Date (). getFullYear ();
                if (minyear> currentyear) renvoie minyear;
                if (maxyear <currentyear) {
                    pour (var maxYearPrefix = maxyear.toString (). slice (0, 2), maxYearPostfix = maxyear.toString (). slice (2, 4); maxyear <maxYearPrefix + indice;) maxYearPrefix--;
                    var maxxYear = maxYearPrefix + maxYearPostfix;
                    retour minyear> maxxYear? minyear: maxxYear;
                }
                if (minyear <= currentyear && currentyear <= maxyear) {
                    pour (var currentYearPrefix = currentyear.toString (). slice (0, 2); maxyear <currentYearPrefix + hint;) currentYearPrefix--;
                    var currentYearAndHint = currentYearPrefix + hint;
                    retourne currentYearAndHint <minyear? minyear: currentYearAndHint;
                }
                retourne l'année en cours;
            },
            onKeyDown: fonction (e, tampon, caretPos, opts) {
                var $ input = $ (this);
                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                    var today = new Date ();
                    $ input.val (today.getDate (). toString () + (today.getMonth () + 1) .toString () + today.getFullYear (). toString ()), 
                    $ input.trigger ("setvalue");
                }
            },
            getFrontValue: function (masque, tampon, opte) {
                pour (var start = 0, length = 0, i = 0; i <mask.length && "2"! == mask.charAt (i); i ++) {
                    var definition = opts.definitions [mask.charAt (i)];
                    définition? (début + = longueur, longueur = définition.cardinalité): longueur ++;
                }
                return buffer.join (""). substr (début, longueur);
            },
            postValidation: fonction (tampon, currentResult, opts) {
                var dayMonthValue, year, bufferStr = buffer.join ("");
                renvoie 0 === opts.mask.indexOf ("y")? (year = bufferStrstr (0, 4), dayMonthValue = bufferStrstr (4, 11)): (year = bufferStrstr (6, 11),
                dayMonthValue = bufferStr.substr (0, 6)), currentResult && (dayMonthValue! == opts.leapday || isLeapYear (year));
            },
            définitions: {
                "1": {
                    validateur: fonction (chrs, maskset, pos, strict, opts) {
                        var isValid = opts.regex.val1.test (chrs);
                        retour strict || isValid || chrs.charAt (1)! == opts.separator && "-./".indexOf(chrs.charAt(1)) === -1 || ! (isValid = opts.regex.val1.test ("0" + chrs.charAt (0)))? isValid: (maskset.buffer [pos - 1] = "0",
                        {
                            refreshFromBuffer: {
                                début: pos - 1,
                                fin: pos
                            },
                            pos: pos,
                            c: chrs.charAt (0)
                        });
                    },
                    cardinalité: 2,
                    prévalidateur: [{
                        validateur: fonction (chrs, maskset, pos, strict, opts) {
                            var pchrs = chrs;
                            isNaN (maskset.buffer [pos + 1]) || (pchrs + = maskset.buffer [pos + 1]);
                            var isValid = 1 === pchrs.length? opts.regex.val1pre.test (pchrs): opts.regex.val1.test (pchrs);
                            si (! strict &&! isValid) {
                                if (isValid = opts.regex.val1.test (chrs + "0")) renvoie maskset.buffer [pos] = chrs, 
                                maskset.buffer [++ pos] = "0", {
                                    pos: pos,
                                    c: "0"
                                };
                                if (isValid = opts.regex.val1.test ("0" + chrs)) renvoie maskset.buffer [pos] = "0", 
                                pos ++, {
                                    pos: pos
                                };
                            }
                            return isValid;
                        },
                        cardinalité: 1
                    }]
                },
                "2": {
                    validateur: fonction (chrs, maskset, pos, strict, opts) {
                        var frontValue = opts.getFrontValue (maskset.mask, maskset.buffer, opts);
                        frontValue.indexOf (opts.placeholder [0])! == -1 && (frontValue = "01" + opts.separator);
                        var isValid = opts.regex.val2 (opts.separator) .test (frontValue + chrs);
                        retour strict || isValid || chrs.charAt (1)! == opts.separator && "-./".indexOf(chrs.charAt(1)) === -1 || ! (isValid = opts.regex.val2 (opts.separator) .test (frontValue + "0" + chrs.charAt (0)))? isValid: (maskset.buffer [pos - 1] = "0",
                        {
                            refreshFromBuffer: {
                                début: pos - 1,
                                fin: pos
                            },
                            pos: pos,
                            c: chrs.charAt (0)
                        });
                    },
                    cardinalité: 2,
                    prévalidateur: [{
                        validateur: fonction (chrs, maskset, pos, strict, opts) {
                            isNaN (maskset.buffer [pos + 1]) || (chrs + = maskset.buffer [pos + 1]);
                            var frontValue = opts.getFrontValue (maskset.mask, maskset.buffer, opts);
                            frontValue.indexOf (opts.placeholder [0])! == -1 && (frontValue = "01" + opts.separator);
                            var isValid = 1 === chrs.length? opts.regex.val2pre (opts.separator) .test (frontValue + chrs): opts.regex.val2 (opts.separator) .test (frontValue + chrs);
                            retour strict || isValid || ! (isValid = opts.regex.val2 (opts.separator) .test (frontValue + "0" + chrs))? isValid: (maskset.buffer [pos] = "0",
                            pos ++, {
                                pos: pos
                            });
                        },
                        cardinalité: 1
                    }]
                },
                y: {
                    validateur: fonction (chrs, maskset, pos, strict, opts) {
                        retourne opts.isInYearRange (chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                    },
                    cardinalité: 4,
                    prévalidateur: [{
                        validateur: fonction (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.isInYearRange (chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                            si (! strict &&! isValid) {
                                var yearPrefix = opts.determinebaseyear (opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0"). toString (). slice (0, 1);
                                if (isValid = opts.isInYearRange (yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) renvoie maskset.buffer [pos ++] = yearPrefix.charAt (0), 
                                {
                                    pos: pos
                                };
                                if (yearPrefix = opts.determinebaseyear (opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0"). toString (). slice (0, 2), 
                                isValid = opts.isInYearRange (yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) renvoie maskset.buffer [pos ++] = yearPrefix.charAt (0), 
                                maskset.buffer [pos ++] = yearPrefix.charAt (1), {
                                    pos: pos
                                };
                            }
                            return isValid;
                        },
                        cardinalité: 1
                    }, {
                        validateur: fonction (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.isInYearRange (chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                            si (! strict &&! isValid) {
                                var yearPrefix = opts.determinebaseyear (opts.yearrange.minyear, opts.yearrange.maxyear, chrs) .toString (). slice (0, 2);
                                if (isValid = opts.isInYearRange (chrs [0] + yearPrefix [1] + chrs [1], opts.yearrange.minyear, opts.yearrange.maxyear) retournent maskset.buffer [pos ++] = yearPrefix.charAt (1) , 
                                {
                                    pos: pos
                                };
                                if (yearPrefix = opts.determinebaseyear (opts.yearrange.minyear, opts.yearrange.maxyear, chrs) .toString (). slice (0, 2), 
                                isValid = opts.isInYearRange (yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) renvoie maskset.buffer [pos - 1] = yearPrefix.charAt (0), 
                                maskset.buffer [pos ++] = yearPrefix.charAt (1), maskset.buffer [pos ++] = chrs.charAt (0), 
                                {
                                    refreshFromBuffer: {
                                        début: pos - 3,
                                        fin: pos
                                    },
                                    pos: pos
                                };
                            }
                            return isValid;
                        },
                        cardinalité: 2
                    }, {
                        validateur: fonction (chrs, maskset, pos, strict, opts) {
                            retourne opts.isInYearRange (chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
                        },
                        cardinalité: 3
                    }]
                }
            },
            insertMode:! 1,
            autoUnmask:! 1
        },
        "mm / jj / aaaa": {
            espace réservé: "mm / jj / aaaa",
            alias: "jj / mm / aaaa",
            regex: {
                val2pre: fonction (séparateur) {
                    var escapedSeparator = Inputmask.escapeRegex.call (this, separator);
                    return new RegExp ("(((0 [13-9] | 1 [012])" + escapedSeparator + "[0-3]) | (02" + escapedSeparator + "[0-2])");
                },
                val2: fonction (séparateur) {
                    var escapedSeparator = Inputmask.escapeRegex.call (this, separator);
                    retourne une nouvelle RegExp ("(((0 [1-9] | 1 [012])" + escapedSeparator + "(0 [1-9] | [12] [0-9])) | ((0 [13-9 ] | 1 [012]) "+ escapedSeparator +" 30) | ((0 [13578] | 1 [02]) "+ escapedSeparator +" 31) ");
                },
                val1pre: new RegExp ("[01]"),
                val1: new RegExp ("0 [1-9] | 1 [012]")
            },
            jour de lundi: "02/29 /",
            onKeyDown: fonction (e, tampon, caretPos, opts) {
                var $ input = $ (this);
                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                    var today = new Date ();
                    $ input.val ((today.getMonth () + 1) .toString () + today.getDate (). toString () + today.getFullYear (). toString ()), 
                    $ input.trigger ("setvalue");
                }
            }
        },
        "aaaa / mm / jj": {
            masque: "y / 1/2",
            espace réservé: "aaaa / mm / jj",
            alias: "mm / jj / aaaa",
            Lundi: "/ 02/29",
            onKeyDown: fonction (e, tampon, caretPos, opts) {
                var $ input = $ (this);
                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                    var today = new Date ();
                    $ input.val (today.getFullYear (). toString () + (today.getMonth () + 1) .toString () + today.getDate (). toString ()), 
                    $ input.trigger ("setvalue");
                }
            }
        },
        "jj.mm.aaaa": {
            masque: "1.2.y",
            espace réservé: "jj.mm.aaaa",
            jour de lundi: "29.02.",
            séparateur: ".",
            alias: "jj / mm / aaaa"
        },
        "jj-mm-aaaa": {
            masque: "1-2-y",
            espace réservé: "jj-mm-aaaa",
            jour de lundi: "29-02-",
            séparateur: "-",
            alias: "jj / mm / aaaa"
        },
        "mm.jj.aaaa": {
            masque: "1.2.y",
            espace réservé: "mm.jj.yyyy",
            jour de mardi: "02.29."
            séparateur: ".",
            alias: "mm / jj / aaaa"
        },
        "mm-jj-aaaa": {
            masque: "1-2-y",
            espace réservé: "mm-jj-aaaa",
            jour de l'an: "02-29-",
            séparateur: "-",
            alias: "mm / jj / aaaa"
        },
        "aaaa.mm.jj": {
            masque: "y.1.2",
            espace réservé: "aaaa.mm.jj",
            jour de mars: ".02.29",
            séparateur: ".",
            alias: "aaaa / mm / jj"
        },
        "aaaa-mm-jj": {
            masque: "y-1-2",
            espace réservé: "aaaa-mm-jj",
            jour de mars: "-02-29",
            séparateur: "-",
            alias: "aaaa / mm / jj"
        },
        date / heure: {
            masque: "1/2 / yh: s",
            espace réservé: "jj / mm / aaaa hh: mm",
            alias: "jj / mm / aaaa",
            regex: {
                hrspre: new RegExp ("[012]"),
                hrs24: nouvelle RegExp ("2 [0-4] | 1 [3-9]"),
                heures: nouvelle RegExp ("[01] [0-9] | 2 [0-4]"),
                ampm: new RegExp ("^ [a | p | A | P] [m | M]"),
                mspre: new RegExp ("[0-5]"),
                ms: new RegExp ("[0-5] [0-9]")
            },
            timeseparator: ":",
            hourFormat: "24",
            définitions: {
                h: {
                    validateur: fonction (chrs, maskset, pos, strict, opts) {
                        if ("24" === opts.hourFormat && 24 === parseInt (chrs, 10)) renvoie maskset.buffer [pos - 1] = "0", 
                        maskset.buffer [pos] = "0", {
                            refreshFromBuffer: {
                                début: pos - 1,
                                fin: pos
                            },
                            c: "0"
                        };
                        var isValid = opts.regex.hrs.test (chrs);
                        if (! strict &&! isValid && (chrs.charAt (1) === opts.timeseparator || "-.:".indexOf(chrs.charAt(1))! == -1) && (isValid = opts. regex.hrs.test ("0" + chrs.charAt (0)))) renvoie maskset.buffer [pos - 1] = "0", 
                        maskset.buffer [pos] = chrs.charAt (0), pos ++, {
                            refreshFromBuffer: {
                                début: pos - 2,
                                fin: pos
                            },
                            pos: pos,
                            c: opts.timeseparator
                        };
                        if (isValid && "24"! == opts.hourFormat && opts.regex.hrs24.test (chrs)) {
                            var tmp = parseInt (chrs, 10);
                            retourne 24 === tmp? (maskset.buffer [pos + 5] = "a", maskset.buffer [pos + 6] = "m"): (maskset.buffer [pos + 5] = "p",
                            maskset.buffer [pos + 6] = "m"), tmp - = 12, tmp <10? (maskset.buffer [pos] = tmp.toString (),
                            maskset.buffer [pos - 1] = "0"): (maskset.buffer [pos] = tmp.toString (). charAt (1), 
                            maskset.buffer [pos - 1] = tmp.toString (). charAt (0)), {
                                refreshFromBuffer: {
                                    début: pos - 1,
                                    fin: pos + 6
                                },
                                c: maskset.buffer [pos]
                            };
                        }
                        return isValid;
                    },
                    cardinalité: 2,
                    prévalidateur: [{
                        validateur: fonction (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.regex.hrspre.test (chrs);
                            retour strict || isValid || ! (isValid = opts.regex.hrs.test ("0" + chrs))? isValid: (maskset.buffer [pos] = "0",
                            pos ++, {
                                pos: pos
                            });
                        },
                        cardinalité: 1
                    }]
                },
                s: {
                    validateur: "[0-5] [0-9]",
                    cardinalité: 2,
                    prévalidateur: [{
                        validateur: fonction (chrs, maskset, pos, strict, opts) {
                            var isValid = opts.regex.mspre.test (chrs);
                            retour strict || isValid || ! (isValid = opts.regex.ms.test ("0" + chrs))? isValid: (maskset.buffer [pos] = "0",
                            pos ++, {
                                pos: pos
                            });
                        },
                        cardinalité: 1
                    }]
                },
                t: {
                    validateur: fonction (chrs, maskset, pos, strict, opts) {
                        retourne opts.regex.ampm.test (chrs + "m");
                    },
                    boîtier: "inférieur",
                    cardinalité: 1
                }
            },
            insertMode:! 1,
            autoUnmask:! 1
        },
        datetime12: {
            masque: "1/2 / yh: st \\ m",
            espace réservé: "jj / mm / aaaa hh: mm xm",
            alias: "datetime",
            hourFormat: "12"
        },
        "mm / jj / aaaa hh: mm xm": {
            masque: "1/2 / yh: st \\ m",
            espace réservé: "mm / jj / aaaa hh: mm xm",
            alias: "datetime12",
            regex: {
                val2pre: fonction (séparateur) {
                    var escapedSeparator = Inputmask.escapeRegex.call (this, separator);
                    return new RegExp ("(((0 [13-9] | 1 [012])" + escapedSeparator + "[0-3]) | (02" + escapedSeparator + "[0-2])");
                },
                val2: fonction (séparateur) {
                    var escapedSeparator = Inputmask.escapeRegex.call (this, separator);
                    retourne une nouvelle RegExp ("(((0 [1-9] | 1 [012])" + escapedSeparator + "(0 [1-9] | [12] [0-9])) | ((0 [13-9 ] | 1 [012]) "+ escapedSeparator +" 30) | ((0 [13578] | 1 [02]) "+ escapedSeparator +" 31) ");
                },
                val1pre: new RegExp ("[01]"),
                val1: new RegExp ("0 [1-9] | 1 [012]")
            },
            jour de lundi: "02/29 /",
            onKeyDown: fonction (e, tampon, caretPos, opts) {
                var $ input = $ (this);
                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                    var today = new Date ();
                    $ input.val ((today.getMonth () + 1) .toString () + today.getDate (). toString () + today.getFullYear (). toString ()), 
                    $ input.trigger ("setvalue");
                }
            }
        },
        "hh: mm t": {
            masque: "h: st \\ m",
            espace réservé: "hh: mm xm",
            alias: "datetime",
            hourFormat: "12"
        },
        "h: s t": {
            masque: "h: st \\ m",
            espace réservé: "hh: mm xm",
            alias: "datetime",
            hourFormat: "12"
        },
        "hh: mm: ss": {
            masque: "h: s: s",
            espace réservé: "hh: mm: ss",
            alias: "datetime",
            autoUnmask:! 1
        },
        "hh: mm": {
            masque: "h: s",
            espace réservé: "hh: mm",
            alias: "datetime",
            autoUnmask:! 1
        },
        rendez-vous amoureux: {
            alias: "jj / mm / aaaa"
        },
        "mm / aaaa": {
            masque: "1 / y",
            espace réservé: "mm / aaaa",
            un jour de congé: "donotuse",
            séparateur: "/",
            alias: "mm / jj / aaaa"
        },
        shamsi: {
            regex: {
                val2pre: fonction (séparateur) {
                    var escapedSeparator = Inputmask.escapeRegex.call (this, separator);
                    return new RegExp ("(((0 [1-9] | 1 [012])" + escapedSeparator + "[0-3])");
                },
                val2: fonction (séparateur) {
                    var escapedSeparator = Inputmask.escapeRegex.call (this, separator);
                    retourne une nouvelle RegExp ("(((0 [1-9] | 1 [012])" + escapedSeparator + "(0 [1-9] | [12] [0-9])) | ((0 [1-9 ] | 1 [012]) "+ escapedSeparator +" 30) | ((0 [1-6]) "+ escapedSeparator +" 31) ");
                },
                val1pre: new RegExp ("[01]"),
                val1: new RegExp ("0 [1-9] | 1 [012]")
            },
            année: {
                minyear: 1300,
                maxyear: 1499
            },
            masque: "y / 1/2",
            Lundi: "/ 12/30",
            espace réservé: "aaaa / mm / jj",
            alias: "mm / jj / aaaa",
            clearIncomplete:! 0
        }
    }), Masque de saisie;
} (jQuery, Inputmask), fonction ($, Inputmask) {
    renvoyer Inputmask.extendDefinitions ({
        UNE: {
            validateur: "[A-Za-z \ u0410- \ u044f \ u0401 \ u0451 \ xc0- \ xff \ xb5]",
            cardinalité: 1,
            boîtier: "supérieur"
        },
        "&": {
            validateur: "[0-9A-Za-z \ u0410- \ u044f \ u0401 \ u0451 \ xc0- \ xff \ xb5]",
            cardinalité: 1,
            boîtier: "supérieur"
        },
        "#": {
            validateur: "[0-9A-Fa-f]",
            cardinalité: 1,
            boîtier: "supérieur"
        }
    }), Inputmask.extendAliases ({
        URL: {
            définitions: {
                je: {
                    validateur: ".",
                    cardinalité: 1
                }
            },
            masque: "(\\ http: //) | (\\ http \\ s: //) | (ftp: //) | (ftp \\ s: //) i {+}",
            insertMode:! 1,
            autoUnmask:! 1,
            mode d'entrée: "url"
        },
        ip: {
            masque: "i [i [i]]. i [i [i]]. i [i [i]]. i [i [i]]",
            définitions: {
                je: {
                    validateur: fonction (chrs, maskset, pos, strict, opts) {
                        return pos - 1> -1 && "." ! == maskset.buffer [pos - 1]? (chrs = maskset.buffer [pos - 1] + chrs,
                        chrs = pos - 2> -1 && "." ! == maskset.buffer [pos - 2]? maskset.buffer [pos - 2] + chrs: "0" + chrs): chrs = "00" + chrs,
                        nouveau RegExp ("25 [0-5] | 2 [0-4] [0-9] | [01] [0-9] [0-9]"). test (chrs);
                    },
                    cardinalité: 1
                }
            },
            onUnMask: function (maskedValue, unmaskedValue, opts) {
                return maskedValue;
            },
            mode d'entrée: "numérique"
        },
        email: {
            masque: "* {1,64} [. * {1,64}] [. * {1,64}] [. * {1,63}] @ - {1,63} .- {1,63} [.- {1,63}] [.- {1,63}] ",
            gourmand:! 1,
            onBeforePaste: function (pastedValue, opts) {
                return colledValue = colledValue.toLowerCase (), colledValue.replace ("mailto:", "");
            },
            définitions: {
                "*": {
                    validateur: "[0-9A-Za-z! # $% & '* + / =? ^ _` {|} ~ -] ",
                    cardinalité: 1,
                    boîtier: "inférieur"
                },
                "-": {
                    validateur: "[0-9A-Za-z-]",
                    cardinalité: 1,
                    boîtier: "inférieur"
                }
            },
            onUnMask: function (maskedValue, unmaskedValue, opts) {
                return maskedValue;
            },
            mode d'entrée: "email"
        },
        Mac: {
            masque: "##:##:##:##:##:##"
        },
        vin: {
            masque: "V {13} 9 {4}",
            définitions: {
                V: {
                    validateur: "[A-HJ-NPR-Za-hj-npr-z \\ d]",
                    cardinalité: 1,
                    boîtier: "supérieur"
                }
            },
            clearIncomplete:! 0,
            autoUnmask:! 0
        }
    }), Masque de saisie;
} (jQuery, Inputmask), fonction ($, Inputmask) {
    retourne Inputmask.extendAliases ({
        numérique: {
            masque: fonction (opte) {
                fonction autoEscape (txt) {
                    pour (var escapedTxt = "", i = 0; i <txt.length; i ++) escapedTxt + = opts.definitions [txt.charAt (i)] || opts.optionalmarker.start === txt.charAt (i) || opts.optionalmarker.end === txt.charAt (i) || opts.quantifiermarker.start === txt.charAt (i) || opts.quantifiermarker.end === txt.charAt (i) || opts.groupmarker.start === txt.charAt (i) || opts.groupmarker.end === txt.charAt (i) || opts.alternatormarker === txt.charAt (i)? "\\" + txt.charAt (i): txt.charAt (i);
                    return escapedTxt;
                }
                if (0! == opts.repeat && isNaN (opts.integerDigits) && (opts.integerDigits = opts.repeat), 
                opts.repeat = 0, opts.groupSeparator === opts.radixPoint && ("." === opts.radixPoint? opts.groupSeparator = ",": "," === opts.radixPoint? opts.groupSeparator = " . ": opts.groupSeparator =" "), 
                "" === opts.groupSeparator && (opts.skipOptionalPartCharacter = no 0), opts.autoGroup = opts.autoGroup && ""! == opts.groupSeparator, 
                opts.autoGroup && ("string" == typeof opts.groupSize && isFinite (opts.groupSize) && (opts.groupSize = parseInt (opts.groupSize)), 
                isFinite (opts.integerDigits))) {
                    var seps = Math.floor (opts.integerDigits / opts.groupSize), mod = opts.integerDigits% opts.groupSize;
                    opts.integerDigits = parseInt (opts.integerDigits) + (0 === mod? seps - 1: seps), 
                    opts.integerDigits <1 && (opts.integerDigits = "*");
                }
                opts.placeholder.length> 1 && (opts.placeholder = opts.placeholder.charAt (0)), 
                "radixFocus" === opts.positionCaretOnClick && "" === opts.placeholder && opts.integerOptional ===! 1 && (opts.positionCaretOnClick = "lvp"), 
                opts.definitions [";"] = opts.definitions ["~"], opts.definitions [";"]. definitionSymbol = "~", 
                opts.numericInput ===! 0 && (opts.positionCaretOnClick = "radixFocus" === opts.positionCaretOnClick? "lvp": opts.positionCaretOnClick, 
                opts.digitsOptional =! 1, isNaN (opts.digits) && (opts.digits = 2), opts.decimalProtect =! 1);
                var masque = "[+]";
                if (mask + = autoEscape (opts.prefix), mask + = opts.integerOptional ===! 0? "~ {1," + opts.integerDigits + "}": "~ {" + opts.integerDigits + "} ", 
                void 0! == opts.digits) {
                    opts.decimalProtect && (opts.radixPointDefinitionSymbol = ":");
                    var dq = opts.digits.toString (). split (",");
                    isFinite (dq [0] && dq [1] && isFinite (dq [1]))? mask + = (opts.decimalProtect? ":": opts.radixPoint) + "; {" + opts.digits + "}": (isNaN (opts.digits) || parseInt (opts.digits)> 0) && ( mask + = opts.digitsOptional? "[" + (opts.decimalProtect? ":": opts.radixPoint) + "; {1," + opts.digits + "}]:: (opts.decimalProtect?": ": opts.radixPoint) + "; {" + opts.digits + "}");
                }
                return mask + = autoEscape (opts.suffix), mask + = "[-]", opts.greedy =! 1, null! == opts.min && (opts.min = opts.min.toString (). replace ( new RegExp (Inputmask.escapeRegex (opts.groupSeparator), "g"), ""), 
                "," === opts.radixPoint && (opts.min = opts.min.replace (opts.radixPoint, "."))), 
                null! == opts.max && (opts.max = opts.max.toString (). replace (new RegExp (Inputmask.escapeRex (opts.groupSeparator), "g"), ""), 
                "," === opts.radixPoint && (opts.max = opts.max.replace (opts.radixPoint, "."))), 
                masque;
            },
            espace réservé: "",
            gourmand:! 1,
            chiffres: "*",
            digitsOptional:! 0,
            radixPoint: ".",
            positionCaretOnClick: "radixFocus",
            groupSize: 3,
            groupSeparator: "",
            autoGroup:! 1,
            allowPlus:! 0,
            allowMinus:! 0,
            negationSymbol: {
                de face: "-",
                retour: ""
            },
            integerDigits: "+",
            integerOptional:! 0,
            préfixe: "",
            suffixe: "",
            rightAlign:! 0,
            decimalProtect:! 0,
            min: null,
            max: null,
            étape 1,
            insertMode:! 0,
            autoUnmask:! 1,
            unmaskAsNumber:! 1,
            mode d'entrée: "numérique",
            postFormat: fonction (tampon, pos, opts) {
                opts.numericInput ===! 0 && (buffer = buffer.reverse (), isFinite (pos) && (pos = buffer.join (""). length - pos - 1));
                var i, l;
                pos = pos> = buffer.length? buffer.length - 1: pos <0? 0: pos;
                var charAtPos = tampon [pos], cbuf = tampon.slice ();
                charAtPos === opts.groupSeparator && (cbuf.splice (pos--, 1), charAtPos = cbuf [pos]);
                var isNegative = cbuf.join (""). match (new RegExp ("^" + Inputmask.escapeRex (opts.negationSymbol.front)));
                isNegative = null! == isNegative && 1 === isNegative.length, pos> (isNegative? opts.negationSymbol.front.length: 0) + opts.prefix.length && pos <cbuf.length - opts.suffix.length && (cbuf [pos] = "!");
                var bufVal = cbuf.join (""), bufValOrigin = cbuf.join ();
                if (isNegative && (bufVal = bufVal.replace (new RegExp ("^" + + Inputmask.escapeRex (opts.negationSymbol.front)), ""), 
                bufVal = bufVal.replace (new RegExp (Inputmask.escapeRex (opts.negationSymbol.back) + "$"), "")), 
                bufVal = bufVal.replace (new RegExp (Inputmask.escapeRex (opts.suffix) + "$"), ""), 
                bufVal = bufVal.replace (new RegExp ("^" + Inputmask.escapeRex (opts.prefix)), ""), 
                bufVal.length> 0 && opts.autoGroup || bufVal.indexOf (opts.groupSeparator)! == -1) {
                    var escapedGroupSeparator = Inputmask.escapeRegex (opts.groupSeparator);
                    bufVal = bufVal.replace (new RegExp (escapedGroupSeparator, "g"), "");
                    var radixSplit = bufVal.split (charAtPos === opts.radixPoint? "!": opts.radixPoint);
                    if (bufVal = "" === opts.radixPoint? bufVal: radixSplit [0], charAtPos! == opts.negationSymbol.front && (bufVal = bufVal.replace ("!", "?")), 
                    bufVal.length> opts.groupSize) pour (var reg = new RegExp ("([- +]? [\\ d?] +) ()] ([\\ d?] {" + opts.groupSize + "})") ; reg.test (bufVal) && ""! == opts.groupSeparator;) bufVal = bufVal.replace (reg, "$ 1" + opts.groupSeparator + "$ 2"), 
                    bufVal = bufVal.replace (opts.groupSeparator + opts.groupSeparator, opts.groupSeparator);
                    bufVal = bufVal.replace ("?", "!"), ""! == opts.radixPoint && radixSplit.length> 1 && (bufVal + = (charAtPos === opts.radixPoint? "!"! ": opts.radixPoint ) + radixSplit [1]);
                }
                bufVal = opts.prefix + bufVal + opts.suffix, isNegative && (bufVal = opts.negationSymbol.front + bufVal + opts.negationSymbol.back);
                var needsRefresh = bufValOrigin! == bufVal.split (""). join (), newPos = $ .inArray ("!", bufVal);
                if (newPos === -1 && (newPos = pos), needsRefresh) {
                    pour (longueur de tampon = longueur de bufVal, i = 0, l = longueur de bufVal; i <l; i ++) tampon [i] = bufVal.charAt (i);
                    tampon [newPos] = charAtPos;
                }
                return newPos = opts.numericInput && isFinite (pos)? buffer.join (""). length - newPos - 1: newPos,
                opts.numericInput && (buffer = buffer.reverse (), $ .inArray (opts.radixPoint, tampon) <newPos && buffer.join (""). length - opts.suffix.length! == newPos && (newPos - = 1)), 
                {
                    pos: newPos,
                    refreshFromBuffer: needsRefresh,
                    tampon: tampon,
                    isNegative: isNegative
                };
            },
            onBeforeWrite: fonction (e, tampon, caretPos, opts) {
                var rslt;
                if (e && ("flou" === e.type || "checkval" === e.type || "keydown" === e.type))) {
                    var maskedValue = opts.numericInput? buffer.slice (). reverse (). join (""): buffer.join (""), processValue = maskedValue.replace (opts.prefix, "");
                    processValue = processValue.replace (opts.suffix, ""), processValue = processValue.replace (new RegExp (Inputmask.escapeRex (opts.groupSeparator), "g"), ""), 
                    "," === opts.radixPoint && (processValue = processValue.replace (opts.radixPoint, "."));
                    var isNegative = processValue.match (new RegExp ("[-" + Inputmask.escapeRex (opts.negationSymbol.front) + "]", "g"));
                    if (isNegative = null! == isNegative && 1 === isNegative.length, processValue = processValue.replace (new RegExp ("[-" + + Inputmask.escapeRex (à propos de. opg.negationSymbol.front) + +]], "g" ), ""), 
                    processValue = processValue.replace (new RegExp (Inputmask.escapeRex (opts.negationSymbol.back) + "$"), ""), 
                    isNaN (opts.placeholder) && (processValue = processValue.replace (new RegExp (Inputmask.escapeRex (opts.placeholder), "g"), "")), 
                    processValue = processValue === opts.negationSymbol.front? processValue + "0": processValue,
                    ""! == processValue && isFinite (processValue)) {
                        var floatValue = parseFloat (processValue), signedFloatValue = isNegative? floatValue * -1: floatValue;
                        if (null! == opts.min && isFinite (opts.min) && signedFloatValue <parseFloat (opts.min)? (floatValue = Math.abs (opts.min), 
                        isNegative = opts.min <0, maskedValue = void 0): null! == opts.max && isFinite (opts.max) && signedFloatValue> parseFloat (opts.max) && (floatValue = Math.abs (opts.max), 
                        isNegative = opts.max <0, maskedValue = void 0), processValue = floatValue.toString (). replace (".", opts.radixPoint) .split (""), 
                        isFinite (opts.digits)) {
                            var radixPosition = $ .inArray (opts.radixPoint, processValue), rpb = $ .inArray (opts.radixPoint, maskedValue);
                            radixPosition === -1 && (processValue.push (opts.radixPoint), radixPosition = processValue.length - 1);
                            pour (var i = 1; i <= opts.digits; i ++) opts.digitsOptional || void 0! == processValue [radixPosition + i] && processValue [radixPosition + i]! == opts.placeholder.charAt (0)? rpb! == -1 && void 0! == maskedValue [rpb + i] && (processValue [radixPosition + i] = processValue [radixPosition + i] || maskedValue [rpb + i]): processValue [radixPosition + i] = "0";
                            processValue [processValue.length - 1] === opts.radixPoint && delete processValue [processValue.length - 1];
                        }
                        if (floatValue.toString ()! == processValue && floatValue.toString () + "."! "! == processValue || isNegative) renvoyer processValue = (opts.prefix + processValue.join (" ")). split (" "). ), 
                        ! isNegative || 0 === floatValue && "blur" === e.type || (processValue.unshift (opts.negationSymbol.front),
                        processValue.push (opts.negationSymbol.back)), opts.numericInput && (processValue = processValue.reverse ()), 
                        rslt = opts.postFormat (processValue, opts.numericInput? caretPos: caretPos - 1, opts), 
                        rslt.buffer && (rslt.refreshFromBuffer = rslt.buffer.join ("")! == buffer.join ("")), 
                        rslt;
                    }
                }
                if (opts.autoGroup) renvoie rslt = opts.postFormat (tampon, opts.numericInput? caretPos: caretPos - 1, opts), 
                rslt.caret = caretPos <(rslt.isNegative? opts.negationSymbol.front.length: 0) + opts.prefix.length || caretPos> rslt.buffer.length - (rslt.isNegative? opts.negationSymbol.back.length: 0)? rslt.pos: rslt.pos + 1,
                rslt;
            },
            regex: {
                integerPart: function (opts) {
                    retourne une nouvelle RegExp ("[" + Inputmask.escapeRex (opts.negationSymbol.front) + "+]? \\ d +");
                },
                integerNPart: function (opts) {
                    return new RegExp ("[\\ d" + Inputmask.escapeRex (opts.groupSeparator) + Inputmask.escapeRex (opts.placeholder.charAt (0)) + "] +");
                }
            },
            signHandler: function (chrs, maskset, pos, strict, opts) {
                if (! strict && opts.allowMinus && "-" === chrs || opts.allowPlus && "+" === chrs) {
                    var matchRslt = maskset.buffer.join (""). match (opts.regex.integerPart (opts));
                    if (matchRslt && matchRslt [0] .length> 0) renvoie maskset.buffer [matchRslt.index] === ("-" === chrs? "+": opts.negationSymbol.front)? "-" === chrs? ""! == opts.negationSymbol.back? {
                        pos: 0,
                        c: opts.negationSymbol.front,
                        enlever: 0,
                        caret: pos,
                        insérer: {
                            pos: maskset.buffer.length - 1,
                            c: opts.negationSymbol.back
                        }
                    }: {
                        pos: 0,
                        c: opts.negationSymbol.front,
                        enlever: 0,
                        caret: pos
                    }: ""! == opts.negationSymbol.back? {
                        pos: 0,
                        c: "+",
                        remove: [0, maskset.buffer.length - 1],
                        caret: pos
                    }: {
                        pos: 0,
                        c: "+",
                        enlever: 0,
                        caret: pos
                    }: maskset.buffer [0] === ("-" === chrs? opts.negationSymbol.front: "+")? "-" === chrs && ""! == opts.negationSymbol.back? {
                        remove: [0, maskset.buffer.length - 1],
                        caret: pos - 1
                    }: {
                        enlever: 0,
                        caret: pos - 1
                    }: "-" === chrs? ""! == opts.negationSymbol.back? {
                        pos: 0,
                        c: opts.negationSymbol.front,
                        caret: pos + 1,
                        insérer: {
                            pos: maskset.buffer.length,
                            c: opts.negationSymbol.back
                        }
                    }: {
                        pos: 0,
                        c: opts.negationSymbol.front,
                        caret: pos + 1
                    }: {
                        pos: 0,
                        c: chrs,
                        caret: pos + 1
                    };
                }
                retourner! 1;
            },
            radixHandler: fonction (chrs, maskset, pos, strict, opts) {
                if (! strict && opts.numericInput! ==! 0 && chrs === opts.radixPoint && void 0! == opts.digits && (isNaN (opts.digits) || parseInt (opts.digits)> 0) {
                    var radixPos = $ .inArray (opts.radixPoint, maskset.buffer), integerValue = maskset.buffer.join (""). match (opts.regex.integerPart (opts));
                    if (radixPos! == -1 && maskset.validPositions [radixPos]) renvoie maskset.validPositions [radixPos - 1]? {
                        caret: radixPos + 1
                    }: {
                        pos: integerValue.index,
                        c: integerValue [0],
                        caret: radixPos + 1
                    };
                    if (! integerValue || "0" === integerValue [0] && integerValue.index + 1! == pos) renvoie maskset.buffer [integerValue? integerValue.index: pos] = "0",
                    {
                        pos: (integerValue? integerValue.index: pos) + 1,
                        c: opts.radixPoint
                    };
                }
                retourner! 1;
            },
            LeadingZeroHandler: fonction (chrs, maskset, pos, strict, opts, isSelection) {
                si (! strict) {
                    var buffer = maskset.buffer.slice ("");
                    if (buffer.splice (0, opts.prefix.length), buffer.splice (buffer.length - opts.suffix.length, opts.suffix.length), 
                    opts.numericInput ===! 0) {
                        var buffer = buffer.reverse (), bufferChar = tampon [0];
                        if ("0" === bufferChar && void 0 === maskset.validPositions [pos - 1]) retourne {
                            pos: pos,
                            remove: buffer.length - 1
                        };
                    } autre {
                        pos - = opts.prefix.length;
                        var radixPosition = $ .inArray (opts.radixPoint, tampon), matchRslt = buffer.slice (0, radixPosition! == -1? radixPosition: void 0) .join (""). match (opts.regex.integerNPart (opts ));
                        if (matchRslt && (radixPosition === -1 || pos <= radixPosition)) {
                            var decimalPart = radixPosition === -1? 0: parseInt (buffer.slice (radixPosition + 1) .join (""));
                            if (0 === matchRslt [0] .indexOf (""!! == opts.placeholder? opts.placeholder.charAt (0): "0") && (matchRslt.index + 1 === pos || isSelection! ==! 0 && 0 === decimalPart)) renvoie maskset.buffer.splice (matchRslt.index + opts.prefix.length, 1), 
                            {
                                pos: matchRslt.index + opts.prefix.length,
                                remove: matchRslt.index + opts.prefix.length
                            };
                            if ("0" === chrs && pos <= matchRslt.index && matchRslt [0]! == opts.groupSeparator) renvoie! 1;
                        }
                    }
                }
                retourner! 0;
            },
            définitions: {
                "~": {
                    validateur: fonction (chrs, maskset, pos, strict, opts, isSelection) {
                        var isValid = opts.signHandler (chrs, maskset, pos, strict, opts);
                        if (! isValid && (isValid = opts.radixHandler (chrs, maskset, pos, strict, opts), 
                        ! isValid && (isValid = strict? new RegExp ("[0-9" + Inputmask.escapeRex (opts.groupSeparator) + "]"). test (chrs): nouveau RegExp ("[0-9]"). test (chrs), 
                        isValid ===! 0 && (isValid = opts.leadingZeroHandler (chrs, maskset, pos, strict, opts, isSelection), 
                        isValid ===! 0))))) {
                            var radixPosition = $ .inArray (opts.radixPoint, maskset.buffer);
                            isValid = radixPosition! == -1 && (opts.digitsOptional ===! 1 || maskset.validPositions [pos]) && opts.numericInput! ==! 0 && pos> radixPosition &&! strict? {
                                pos: pos,
                                enlever: pos
                            }: {
                                pos: pos
                            };
                        }
                        return isValid;
                    },
                    cardinalité: 1
                },
                "+": {
                    validateur: fonction (chrs, maskset, pos, strict, opts) {
                        var isValid = opts.signHandler (chrs, maskset, pos, strict, opts);
                        return! isValid && (strict && opts.allowMinus && chrs === opts.negationSymbol.front || opts.allowMinus && "-" = "= chrs || opts.allowPlus && "+" === chrs) && (isValid =! (! strict && "-" === chrs) || (""! == opts.negationSymbol.back? {?
                            pos: pos,
                            c: "-" === chrs? opts.negationSymbol.front: "+",
                            caret: pos + 1,
                            insérer: {
                                pos: maskset.buffer.length,
                                c: opts.negationSymbol.back
                            }
                        }: {
                            pos: pos,
                            c: "-" === chrs? opts.negationSymbol.front: "+",
                            caret: pos + 1
                        })), est valable;
                    },
                    cardinalité: 1,
                    espace réservé: ""
                },
                "-": {
                    validateur: fonction (chrs, maskset, pos, strict, opts) {
                        var isValid = opts.signHandler (chrs, maskset, pos, strict, opts);
                        return! isValid && strict && opts.allowMinus && chrs === opts.negationSymbol.back && (isValid =! 0), 
                        est valable;
                    },
                    cardinalité: 1,
                    espace réservé: ""
                },
                ":": {
                    validateur: fonction (chrs, maskset, pos, strict, opts) {
                        var isValid = opts.signHandler (chrs, maskset, pos, strict, opts);
                        si (! isValid) {
                            var radix = "[" + Inputmask.escapeRex (opts.radixPoint) + "]";
                            isValid = new RegExp (radix) .test (chrs), isValid && maskset.validPositions [pos] && maskset.validPositions [pos] .match.placeholder === opts.radixPoint && (isValid = {
                                caret: pos + 1
                            });
                        }
                        return isValid;
                    },
                    cardinalité: 1,
                    espace réservé: fonction (opts) {
                        renvoyer opts.radixPoint;
                    }
                }
            },
            onUnMask: function (maskedValue, unmaskedValue, opts) {
                if ("" === unmaskedValue && opts.nullable ===! 0) renvoie unmaskedValue;
                var processValue = maskedValue.replace (opts.prefix, "");
                return processValue = processValue.replace (opts.suffix, ""), processValue = processValue.replace (new RegExp (Inputmask.escapeRegex (opts.groupSeparator), "g"), ""), 
                opts.unmaskAsNumber? (""! == opts.radixPoint && processValue.indexOf (opts.radixPoint)! == -1 && (processValue = processValue.replace (Inputmask.escapeRegex.call (this, opts.radixPoint), ".")),
                Nombre (processValue)): processValue;
            },
            isComplete: function (tampon, opts) {
                var maskedValue = buffer.join (""), bufClone = buffer.slice ();
                if (opts.postFormat (bufClone, 0, opts), bufClone.join ("")! == maskedValue) retourne! 1;
                var processValue = maskedValue.replace (opts.prefix, "");
                return processValue = processValue.replace (opts.suffix, ""), processValue = processValue.replace (new RegExp (Inputmask.escapeRegex (opts.groupSeparator), "g"), ""), 
                "," === opts.radixPoint && (processValue = processValue.replace (Inputmask.escapeRex (opts.radixPoint), ".")), 
                isFinite (processValue);
            },
            onBeforeMask: function (initialValue, opts) {
                if (opts.numericInput ===! 0 && (initialValue = initialValue.split (""). reverse (). join ("")), 
                ""! == opts.radixPoint && isFinite (initialValue)) {
                    var vs = initialValue.split ("."), groupSize = ""! == opts.groupSeparator? parseInt (opts.groupSize): 0;
                    2 === vslength && (vs [0] .length> groupSize || vs [1] .length> groupSize) && (initialValue = initialValue.toString (). Replace (".", Opts.radixPoint));
                }
                var kommaMatches = initialValue.match (/, / g), dotMatches = initialValue.match (/\./ g);
                if (dotMatches && kommaMatches? dotMatches.length> kommaMatches.length? (initialValue = initialValue.replace (/\./ g, ""), 
                initialValue = initialValue.replace (",", opts.radixPoint)): kommaMatches.length> dotMatches.length? (initialValue = initialValue.replace (/, / g, ""),
                initialValue = initialValue.replace (".", opts.radixPoint)): initialValue = initialValue.indexOf (".") <initialValue.indexOf (",")? initialValue.replace (/\./ g, ""): initialValue = initialValue.replace (/, / g, ""): initialValue = initialValue.replace (new RegExp (Inputmask.escapeRegex (opts.groupSeparator)), "g" ), ""),
                0 === opts.digits && (initialValue.indexOf (".")!! == -1? InitialValue = initialValue.substring (0, initialValue.indexOf (".")): InitialValue.indexOf (",")! == -1 && (initialValue = initialValue.substring (0, initialValue.indexOf (",")))), 
                ""! == opts.radixPoint && isFinite (opts.digits) && initialValue.indexOf (opts.radixPoint)! == -1) {
                    var valueParts = initialValue.split (opts.radixPoint), decPart = valueParts [1] .match (new RegExp ("\\ d *")) [0];
                    if (parseInt (opts.digits) <decPart.toString (). length) {
                        var digitsFactor = Math.pow (10, parseInt (opts.digits));
                        initialValue = initialValue.replace (Inputmask.escapeRex (opts.radixPoint), "."), 
                        initialValue = Math.round (parseFloat (initialValue) * digitsFactor) / digitsFactor, 
                        initialValue = initialValue.toString (). replace (".", opts.radixPoint);
                    }
                }
                return opts.numericInput ===! 0 && (initialValue = initialValue.split (""). reverse (). join ("")), 
                initialValue.toString ();
            },
            canClearPosition: fonction (maskset, position, lvp, strict, opts) {
                var positionInput = maskset.validPositions [position] .input, canClear = positionInput! == opts.radixPoint || null! == maskset.validPositions [position] .match.fn && opts.decimalProtect ===! 1 || isFinite (positionInput) || position === lvp || positionInput === opts.groupSeparator || positionInput === opts.negationSymbol.front || positionInput === opts.negationSymbol.back;
                return canClear;
            },
            onKeyDown: fonction (e, tampon, caretPos, opts) {
                var $ input = $ (this);
                if (e.ctrlKey) commutateur (e.keyCode) {
                  case Inputmask.keyCode.UP:
                    $ input.val (parseFloat (this.inputmask.unmaskedvalue ()) + parseInt (opts.step)), $ input.trigger ("setvalue");
                    Pause;

                  case Inputmask.keyCode.DOWN:
                    $ input.val (parseFloat (this.inputmask.unmaskedvalue ()) - parseInt (opts.step)), $ input.trigger ("setvalue");
                }
            }
        },
        devise: {
            préfixe: "$",
            groupSeparator: ",",
            alias: "numérique",
            espace réservé: "0",
            autoGroup:! 0,
            chiffres: 2,
            digitsOptional:! 1,
            clearMaskOnLostFocus:! 1
        },
        décimal: {
            alias: "numérique"
        },
        entier: {
            alias: "numérique",
            chiffres: 0,
            radixPoint: ""
        },
        pourcentage: {
            alias: "numérique",
            chiffres: 2,
            radixPoint: ".",
            espace réservé: "0",
            autoGroup:! 1,
            min: 0,
            max: 100
            suffixe: "%",
            allowPlus:! 1,
            allowMinus:! 1
        }
    }), Masque de saisie;
} (jQuery, Inputmask), fonction ($, Inputmask) {
    fonction maskSort (a, b) {
        var maska ​​= (a.mask || a) .remplacer (/ # / g, "9"). remplacer (/ \) /, "9"). remplacer (/ [+ () # -] / g, " "), maskb = (b.mask || b) .remplacer (/ # / g," 9 "). remplacer (/ \) /," 9 "). remplacer (/ [+ () # -] / g , ""), maskas = (a.mask || a) .split ("#") [0], maskbs = (b.mask || b) .split ("#") [0];
        retourne 0 === maskbs.indexOf (maskas)? -1: 0 === maskas.indexOf (maskbs)? 1: maska.localeCompare (maskb);
    }
    var analyseMaskBase = Inputmask.prototype.analyseMask;
    return Inputmask.prototype.analyseMask = function (masque, opte) {
        function reductionVariations (masques, previousVariation, previousmaskGroup) {
            previousVariation = previousVariation || "", previousmaskGroup = previousmaskGroup || maskGroups,
            ""! == previousVariation && (previousmaskGroup [previousVariation] = =});
            for (var variation = "", maskGroup = previousmaskGroup [previousVariation] || previousmaskGroup, i = masks.length - 1; i> = 0; i--) masque = masques [i] .mask || masques [i],
            variation = mask.substr (0, 1), maskGroup [variation] = maskGroup [variation] || []
            maskGroup [variation] .unshift (mask.substr (1)), masks.splice (i, 1);
            pour (var ndx dans maskGroup) maskGroup [ndx] .length> 500 && reductionVariations (maskGroup [ndx] .slice (), ndx, maskGroup);
        }
        fonction reconstruire (maskGroup) {
            var masque = "", submasks = [];
            pour (var ndx dans maskGroup) $ .isArray (maskGroup [ndx])? 1 === maskGroup [ndx] .length? submasks.push (ndx + maskGroup [ndx]): submasks.push (ndx + opts.groupmarker.start + maskGroup [ndx] .join (opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts. groupmarker.end): submasks.push (ndx + rebuild (maskGroup [ndx]));
            return mask + = 1 === submasks.length? submasks [0]: opts.groupmarker.start + submasks.join (opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end;
        }
        var maskGroups = {};
        opts.phoneCodes && opts.phoneCodes.length> 1e3 && (mask = mask.substr (1, mask.length - 2), 
        reductionVariations (mask.split (opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start)), 
        mask = reconstruit (maskGroups));
        var mt = analyseMaskBase.call (this, masque, opte);
        retour mt;
    }, Inputmask.extendAliases ({
        abstractphone: {
            marqueur de groupe: {
                commencer: "<",
                fin: ">"
            },
            code postal: "",
            phoneCodes: [],
            masque: fonction (opte) {
                return opts.definitions = {
                    "#": opts.definitions [9]
                }, opts.phoneCodes.sort (maskSort);
            },
            keepStatic:! 0,
            onBeforeMask: function (valeur, opte) {
                var processingValue = value.replace (/ ^ 0 {1,2} /, "") .replace (/ [\ s] / g, "");
                return (transformationValue.indexOf (opts.countrycode)> 1 || transformationValue.indexOf (opts.countrycode) === -1) && (transformationValue = "+" + opts.countrycode + processingValue), 
                valeur traitée;
            },
            onUnMask: function (maskedValue, unmaskedValue, opts) {
                return unmaskedValue;
            },
            mode d'entrée: "tel"
        }
    }), Masque de saisie;
} (jQuery, Inputmask), fonction ($, Inputmask) {
    retourne Inputmask.extendAliases ({
        Regex: {
            masque: "r",
            gourmand:! 1,
            répéter: "*",
            regex: null,
            regexTokens: null,
            tokenizer: / \ [\ ^?]? (?: [^ \\\]] + | \\ [\ S \ s]?) *]? | \\ (?: 0 (?: [0-3] [0-7] {0,2} | [4-7] [0-7]?) | | [1-9] [0-9] * | x ​​[0-9A-Fa-f] {2} | u [0-9A-Fa-f] {4} | c [A-Za-z] | [\ S \ s]?) | \ (?: \? [? =!]?)? | ?: [? * +] | \ {[0-9] + (?:, [0-9] *)? \}) \ ?? | [^.? * + ^ $ {[() | \\ ] + | ./g,
            quantifierFilter: / [0-9] + [^,] /,
            isComplete: function (tampon, opts) {
                retourne une nouvelle RegExp (opts.regex) .test (buffer.join (""));
            },
            définitions: {
                r: {
                    validateur: fonction (chrs, maskset, pos, strict, opts) {
                        fonction RegexToken (isGroup, isQuantifier) ​​{
                            this.matches = [], this.isGroup = isGroup || ! 1, this.isQuantifier = isQuantifier || !1,
                            this.quantifier = {
                                min: 1,
                                max: 1
                            }, this.repeaterPart = void 0;
                        }
                        fonction analyseRegex () {
                            correspondance var, m, currentToken = new RegexToken (), opengroups = [];
                            pour (opts.regexTokens = []; match = opts.tokenizer.exec (opts.regex);) commutateur (m = match [0], 
                            m.charAt (0)) {
                              Cas "(":
                                opengroups.push (new RegexToken ((! 0)));
                                Pause;

                              Cas ")":
                                groupToken = opengroups.pop (), opengroups.length> 0? opengroups [opengroups.length - 1] .matches.push (groupToken): currentToken.matches.push (groupToken);
                                Pause;

                              Cas "{":
                              case "+":
                              Cas "*":
                                var quantifierToken = new RegexToken ((! 1), (! 0));
                                m = m.replace (/ [{}] / g, "");
                                var mq = m.split (","), mq0 = isNaN (mq [0])? mq [0]: parseInt (mq [0]), mq1 = 1 === mq.length? mq0: isNaN (mq [1])? mq [1]: analyseInt (mq [1]);
                                if (quantifierToken.quantifier = {
                                    min: mq0,
                                    max: mq1
                                }, opengroups.length> 0) {
                                    var matches = opengroups [opengroups.length - 1] .matches;
                                    match = matches.pop (), match.isGroup || (groupToken = new RegexToken ((! 0)), groupToken.matches.push (match),
                                    match = groupToken), matches.push (match), matches.push (quantifierToken);
                                } else match = currentToken.matches.pop (), match.isGroup || (groupToken = new RegexToken ((! 0)),
                                groupToken.matches.push (match), match = groupToken), currentToken.matches.push (match), 
                                currentToken.matches.push (quantifierToken);
                                Pause;

                              défaut:
                                opengroups.length> 0? opengroups [opengroups.length - 1] .matches.push (m): currentToken.matches.push (m);
                            }
                            currentToken.matches.length> 0 && opts.regexTokens.push (currentToken);
                        }
                        fonction validateRegexToken (jeton, fromGroup) {
                            var isvalid =! 1;
                            fromGroup && (regexPart + = "(", openGroupCount ++);
                            pour (var mndx = 0; mndx <token.matches.length; mndx ++) {
                                var matchToken = token.matches [mndx];
                                if (matchToken.isGroup ===! 0) isvalid = validateRegexToken (matchToken,! 0); else if (matchToken.isQuantifier ===! 0) {
                                    var crrntndx = $ .inArray (matchToken, token.matches), matchGroup = token.matches [crrntndx - 1], regexPartBak = regexPart;
                                    if (isNaN (matchToken.quantifier.max)) {
                                        pour (; matchToken.repeaterPart && matchToken.repeaterPart! == regexPart && matchToken.repeaterPart.length> regexPart.length &&! (isvalid = validateRegexToken (matchGroup,! 0));
                                        isvalid = isvalid || validateRegexToken (matchGroup,! 0), isvalid && (matchToken.repeaterPart = regexPart),
                                        regexPart = regexPartBak + matchToken.quantifier.max;
                                    } autre {
                                        pour (var i = 0, qm = matchToken.quantifier.max - 1; i <qm &&! (isvalid = validateRegexToken (matchGroup,! 0)); i ++);
                                        regexPart = regexPartBak + "{" + matchToken.quantifier.min + "," + matchToken.quantifier.max + "}";
                                    }
                                } else if (void 0! == matchToken.matches) pour (var k = 0; k <matchToken.length &&! (isvalid = validateRegexToken (matchToken [k], fromGroup)); k ++); autre {
                                    var testExp;
                                    if ("[" == matchToken.charAt (0)) {
                                        testExp = regexPart, testExp + = matchToken;
                                        pour (var j = 0; j <openGroupCount; j ++) testExp + = ")";
                                        var exp = new RegExp ("^ (" + testExp + ") $");
                                        isvalid = exp.test (bufferStr);
                                    } else pour (var l = 0, tl = matchToken.length; l <tl; l ++) if ("\\"! == matchToken.charAt (l)) {
                                        testExp = regexPart, testExp + = matchToken.substr (0, l + 1), testExp = testExp.replace (/ \ | $ /, "");
                                        pour (var j = 0; j <openGroupCount; j ++) testExp + = ")";
                                        var exp = new RegExp ("^ (" + testExp + ") $");
                                        if (isvalid = exp.test (bufferStr)) break;
                                    }
                                    regexPart + = matchToken;
                                }
                                si pause (non valide);
                            }
                            return fromGroup && (regexPart + = ")", openGroupCount--), isvalid;
                        }
                        var bufferStr, groupToken, cbuffer = maskset.buffer.slice (), regexPart = "", isValid =! 1, openGroupCount = 0;
                        null === opts.regexTokens && analyseRegex (), cbuffer.splice (pos, 0, chrs), bufferStr = cbuffer.join ("");
                        pour (var i = 0; i <opts.regexTokens.length; i ++) {
                            var regexToken = opts.regexTokens [i];
                            if (isValid = validateRegexToken (regexToken, regexToken.isGroup)) break;
                        }
                        return isValid;
                    },
                    cardinalité: 1
                }
            }
        }
    }), Masque de saisie;
} (jQuery, Inputmask);